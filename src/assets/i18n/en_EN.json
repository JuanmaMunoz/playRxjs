{
  "english": "English",
  "spanish": "Spanish",
  "combination": {
    "title": "Combination operators",
    "description": "<b>Combination operators in RxJS</b> allow you to work with multiple observables to <b>combine them</b> and <b>create new</b> data streams flexibly. Each operator has a specific purpose depending on how you want to combine the values from the observables.",
    "shortDescription": "Combination operators are key tools for managing real-time or asynchronous data streams.",
    "combineLatest": {
      "title": "Operator combineLatest",
      "description": "<p>The <b>combineLatest</b> operator in RxJS is a way to combine multiple observables into a single one, emitting the <b>latest value</b> from each of them along with the <b>sequence of values</b> from the latest observable.</p>"
    },
    "concat": {
      "title": "Operator concat",
      "description": "<p>The <b>concat</b> operator in RxJS combines multiple observables sequentially, emitting the values from <b>one until it completes</b>, and then moves on to the <b>next</b>.</p>"
    },
    "concatAll": {
      "title": "Operator concatAll",
      "description": "<p>The <b>concatAll</b> operator in RxJS is used to <b>'flatten'</b> a stream of observables sequentially. This means that if you have an observable that emits other observables, <b>concatAll</b> takes those observables and emits them <b>one by one</b>, in the order they were emitted, waiting for each one to complete before moving on to the next.</p>"
    },
    "exhaust": {
      "title": "Operator exhaust",
      "description": "<p>The <b>exhaust</b> operator in RxJS is used to handle observable streams in such a way that, when a source observable emits a new observable, the operator <b>will only listen to the first</b> observable and any new observables emitted will be ignored until the <b>first one completes</b>. In other words, if the source observable continues emitting observables but is already 'working' with one, those new observables will not be listened to until the previous one completes.</p><p>In this example, we can observe how the delay of the second observable prevents the third observable from executing.</p>"
    },
    "forkJoin": {
      "title": "Operator forkJoin",
      "description": "<p>The <b>forkJoin</b> operator in RxJS is used to wait for all the observables passed as arguments to <b>complete</b>, and when all of them have emitted their last value, it emits a single <b>array with the last values</b> from each of those observables.</p>"
    },
    "merge": {
      "title": "Operator merge",
      "description": "<p>The <b>merge operator</b> in RxJS is used to combine multiple observables and emit their values in an <b>interleaved</b> manner (without waiting for one to complete before listening to the next). The values are emitted in the <b>same order</b> in which the observables produce them, and all the observables are subscribed to and executed <b>simultaneously</b>.</p>"
    },
    "mergeAll": {
      "title": "Operator mergeAll",
      "description": "<p>The <b>mergeAll</b> operator in RxJS is used to flatten an observable stream, but in a <b>different</b> way compared to other operators like <b>concatAll</b>. With <b>mergeAll</b>, when an observable emits other observables, <b>all</b> the observables are subscribed to and executed <b>simultaneously</b>.</p>"
    },
    "race": {
      "title": "Operator race",
      "description": "<p>The <b>race</b> operator in RxJS is used to <b>race</b> between multiple observables and emit the values of the <b>first observable that emits something</b>. In other words, of all the observables passed to it, the operator subscribes only to the one that emits a value first, and <b>ignores</b> the other observables.</p>"
    },
    "startWith": {
      "title": "Operator startWith",
      "description": "<p>The <b>startWith</b> operator in RxJS is used to emit an <b>initial value before</b> any other value is emitted by the observable. In other words, you can specify a value that will be emitted first, before the observable starts emitting its own values.</p>"
    },
    "switchAll": {
      "title": "Operator switchAll",
      "description": "<p>The <b>switchAll</b> operator in RxJS is used to flatten an observable stream, but in a special way: when an observable emits a <b>new observable</b>, switchAll <b>stops listening</b> to the previous observable and starts listening to the new observable. In other words, it always subscribes only to the <b>last emitted observable(s)</b> and cancels the subscription to the previous ones.</p>"
    },
    "withLatestFrom": {
      "title": "Operator withLatestFrom",
      "description": "<p>The <b>withLatestFrom</b> operator in RxJS is used to combine the <b>latest</b> value from one observable with the values of another observable, <b>without subscribing to the second observable</b>. This means that when the first observable emits a value, withLatestFrom takes the latest value from the second observable and combines it with the value emitted by the first observable.</p>"
    }
  },
  "conditional": {
    "title": "Conditional operators",
    "description": "<b>Conditional operators in RxJS</b> are used to handle data streams in a <b>conditional</b> manner, meaning to execute logic based on whether or not a certain condition is met.",
    "shortDescription": "Conditional operators in RxJS are used to handle data streams in a <b>conditional</b> manner, meaning to execute logic based on whether or not a certain condition is met.",
    "defaultIfEmpty": {
      "title": "Operator defaultIfEmpty",
      "description": "<p>The <b>defaultIfEmpty</b> operator in RxJS is used to provide a <b>default value</b> when an observable <b>does not emit any value</b>. That is, if the observable is empty (does not emit anything), defaultIfEmpty emits the value you specify as the default.</p></p>"
    },
    "every": {
      "title": "Operator every",
      "description": "<p>The <b>every</b> operator in RxJS is used to check if all the values emitted by an observable <b>satisfy a specific condition</b>. It returns an observable that <b>emits true</b> if all the emitted values satisfy the condition, and <b>false</b> if at least one of the values does not satisfy it.</p>"
    },
    "find": {
      "title": "Operator find",
      "description": "<p>The <b>find</b> operator in RxJS is used to search for the <b>first value</b> that satisfies a specific condition in an observable. Unlike other operators like <b>filter</b>, which emits <b>all</b> the values that satisfy the condition, find returns only the first value that satisfies the condition or undefined if no value does.</p>"
    },
    "findIndex": {
      "title": "Operator findIndex",
      "description": "<p>The <b>findIndex</b> operator in RxJS is very similar to the find operator, but instead of returning the first value that satisfies a condition, it <b>returns the index</b> of that value. If no value satisfies the condition, it returns <b>-1</b>.</p>"
    },
    "isEmpty": {
      "title": "Operator isEmpty",
      "description": "<p>The <b>isEmpty</b> operator in RxJS is used to check if an observable <b>does not emit any value</b>. It returns an observable that emits:</p><p>- <b>true</b> if the observable does not emit any value.</p><p>- <b>false</b> if the observable emits at least one value.</p>"
    },
    "sequenceEqual": {
      "title": "Operator sequenceEqual",
      "description": "<p><p>The <b>sequenceEqual</b> operator in RxJS is used to check if <b>two observables</b> emit exactly <b>the same sequence of values, in the same order</b>.</p>"
    }
  },
  "creation": {
    "title": "Creation operators",
    "description": "<b>In RxJS, creation operators</b> are functions that <b>generate observables</b> from scratch or from other values or structures. These operators allow creating data streams that can then be processed.",
    "shortDescription": "In RxJS, creation operators are functions that generate observables from scratch or from other values or structures.",
    "ajax": {
      "title": "Operator ajax",
      "description": "<p>The <b>ajax</b> operator in RxJS is a utility for <b>making HTTP requests</b> (such as GET, POST, PUT, DELETE) easily and handling responses as observables. It is ideal for working with data from APIs.</p>"
    },
    "defer": {
      "title": "Operator defer",
      "description": "<p>The <b>defer</b> operator in RxJS is like an <b>'observable factory'</b>. Its main purpose is to create a <b>new observable</b> when someone <b>subscribes</b>, instead of doing so immediately. This allows the observable to be generated on demand, ensuring it always runs with the most updated logic or data.</p>"
    },
    "from": {
      "title": "Operator from",
      "description": "<p>The <b>from</b> operator is like a bridge between common JavaScript structures and the reactive world of RxJS. It converts things like <b>arrays and promises into observables</b> that you can use in your reactive streams.</p>"
    },
    "fromEvent": {
      "title": "Operator fromEvent",
      "description": "<p>The <b>fromEvent</b> operator in RxJS converts an <b>event into an observable</b>. This means you can listen to events, such as mouse clicks, cursor movements, key presses, and work with them as data streams.</p>"
    },
    "generate": {
      "title": "Operator generate",
      "description": "<p>The <b>generate</b> operator in RxJS is an advanced way to <b>create observables</b> that emit a sequence of values based on a <b>generator function</b>. It allows you to generate a custom data stream by specifying conditions for starting, continuing, and updating the emitted values.</p>"
    },
    "iif": {
      "title": "Operator iif",
      "description": "<p>The <b>iif</b> operator in RxJS is a way to create a conditional observable. In other words, iif allows you to <b>decide</b> which observable to emit based on a condition.</p>"
    },
    "interval": {
      "title": "Operator interval",
      "description": "<p>The <b>interval</b> operator in RxJS <b>creates</b> an observable that emits <b>numeric values</b> continuously, starting from 0, and then incrementing each time after a specific time interval.</p>"
    },
    "of": {
      "title": "Operator of",
      "description": "<p>The <b>of</b> operator in RxJS creates an observable from a set of values you pass to it. These values can be <b>any type of data</b>, such as numbers, strings, objects, etc.</p>"
    },
    "range": {
      "title": "Operator range",
      "description": "<p><p>The <b>range</b> operator in RxJS creates an observable that emits a sequence of numbers within a specified range, starting from an <b>initial</b> value and up to a <b>final</b> value.</p>"
    },
    "throwError": {
      "title": "Operator throwError",
      "description": "<p>The <b>throwError</b> operator in RxJS is used to <b>emit an error</b> in an observable manually. This is useful when you want a data stream to stop due to a specific condition and handle an error.</p>"
    },
    "timer": {
      "title": "Operator timer",
      "description": "<p><p>The <b>timer</b> operator in RxJS creates an observable that emits a value <b>after a certain period of time</b> (in milliseconds) and can then continue emitting values at regular intervals if specified.</p>"
    }
  },
  "filtering": {
    "title": "Filtering operators",
    "description": "In RxJS, <b>filtering operators</b> are used to <b>filter</b> the items emitted by an observable, allowing only those that meet a specific condition to pass through. These operators are useful for working with data streams, ensuring that only the relevant values are processed.",
    "shortDescription": "In RxJS, filtering operators are used to filter the items emitted by an observable, allowing only those that meet a specific condition to pass through.",
    "audit": {
      "title": "Operator audit",
      "description": "<p>The <b>audit</b> operator in RxJS is used to <b>control the emission</b> of values from an observable, based on another observable that acts as a <b>'time window'</b>.</p>"
    },
    "auditTime": {
      "title": "Operator auditTime",
      "description": "<p>The <b>auditTime</b> operator in RxJS is a simple way to control the frequency at which values are emitted by an observable. It works <b>similarly to audit</b>, but instead of relying on an external observable, it uses a <b>fixed time period</b> that you define.</p>"
    },
    "debounce": {
      "title": "Operator debounce",
      "description": "<p>The <b>debounce</b> operator in RxJS is useful for controlling <b>how many values</b> from an observable are processed, especially when the values arrive quickly (like key presses or clicks). This operator <b>waits for a period of time</b> after receiving a value, and only emits that value if no new values are received during that time.</p><p>In this example, we will log the last key pressed to the console.</p>"
    },
    "debounceTime": {
      "title": "Operator debounceTime",
      "description": "<p>The <b>debounceTime</b> operator in RxJS is very similar to debounce, but instead of using an observable to define the wait time, it simply uses <b>a fixed time period</b>.</p>"
    },
    "distinct": {
      "title": "Operator distinct",
      "description": "<p>The <b>distinct</b> operator in RxJS is used to <b>filter duplicate values</b> that an observable may emit. It only emits <b>unique values</b> (i.e., those that do not repeat) and discards the values that have already been emitted.</p>"
    },
    "distinctUntilChanged": {
      "title": "Operator distinctUntilChanged",
      "description": "<p>The <b>distinctUntilChanged</b> operator in RxJS is used to filter <b>consecutive repeated</b> values in a data stream. It emits a value only if it is different from the last emitted value.</p>"
    },
    "distinctUntilKeyChanged": {
      "title": "Operator distinctUntilKeyChanged",
      "description": "<p>The <b>distinctUntilKeyChanged</b> operator in RxJS is very similar to distinctUntilChanged, but it is used when the values emitted by the observable are <b>objects</b> or contain properties, and you want to filter out values that have not changed in <b>a specific property</b>.</p>"
    },
    "elementAt": {
      "title": "Operator elementAt",
      "description": "<p>The <b>elementAt</b> operator in RxJS is used to get a <b>specific value at a given position</b> from a data stream emitted by an observable.</p>"
    },
    "filter": {
      "title": "Operator filter",
      "description": "<p>The <b>filter</b> operator in RxJS is used to filter the values emitted by an observable, allowing only the values that <b>meet a specific condition</b> to pass through.</p><p>In this example, we filter for users who are older than 3 years and have different names.</p>"
    },
    "first": {
      "title": "Operator first",
      "description": "<p>The <b>first</b> operator in RxJS is used to emit only the <b>first value</b> of an observable that <b>meets a specific condition</b>, or simply the <b>first</b> value if <b>no</b> condition is defined.</p>"
    }
  },
  "mathematical": {
    "title": "Mathematical operators",
    "description": "<b>Mathematical operators in RxJS</b> are used to perform calculations and <b>mathematical transformations</b> on the values emitted by an observable. These operators allow summing, averaging, or finding minimum or maximum values within a data stream.",
    "shortDescription": "Mathematical operators in RxJS are used to perform calculations and mathematical transformations on the values emitted by an observable.",
    "count": {
      "title": "Operator count",
      "description": "<p>The <b>count</b> operator in RxJS is used to count the <b>number of values</b> emitted by an observable <b>that meet a specific condition</b>. If no condition is provided, it counts all emitted values.</p>"
    },
    "max": {
      "title": "Operator max",
      "description": "<p>The <b>max</b> operator in RxJS is used to find the <b>maximum value</b> emitted by an observable. This operator compares all emitted values and returns the highest one.</p>"
    },
    "min": {
      "title": "Operator min",
      "description": "<p>The <b>min</b> operator in RxJS is used to find the <b>minimum value</b> emitted by an observable. This operator compares all emitted values and returns the lowest one.</p>"
    },
    "reduce": {
      "title": "Operador reduce",
      "description": "<p>The <b>reduce</b> operator in RxJS is used to <b>accumulate the values emitted</b> by an observable, similar to how reduce works in JavaScript arrays. It takes all the emitted values and combines them into a single final value.</p>"
    }
  },
  "multicasting": {
    "title": "Multicasting operators",
    "description": "<b>Multicasting operators in RxJS</b> are used to share <b>a single stream of values</b> among multiple subscribers, so the values emitted by the observable are not repeated for each subscriber. This <b>optimizes performance</b> by preventing values from being emitted multiple times for each subscriber.",
    "shortDescription": "Multicasting operators in RxJS are used to share a single stream of values among multiple subscribers, so the values emitted by the observable are not repeated for each subscriber.",
    "connect": {
      "title": "Operator connect",
      "description": "<p>The <b>connect</b> operator in RxJS is used to <b>activate</b> an observable that is configured to be shared through a subject (usually with publish() or multicast()). This operator allows the observable to start emitting values only after <b>connect()</b> is called, meaning it controls when the observable starts emitting values.</p>"
    },
    "share": {
      "title": "Operator share",
      "description": "<p>The <b>share</b> operator in RxJS is a form of multicast that allows a <b>single data stream</b> emitted by an observable to be shared among multiple subscribers, without each subscriber <b>receiving its own emissions</b>. This prevents the observable from being executed <b>more than once</b>, optimizing performance.</p>"
    },
    "shareReplay": {
      "title": "Operator shareReplay",
      "description": "<p>The <b>shareReplay</b> operator in RxJS is similar to the <b>share</b> operator, but with a key difference: <b>it caches the last emitted values from the observable and replays (replays) them to new subscribers</b>. It is useful when you want new subscribers to receive the latest emitted values without re-executing the entire data flow.</p>"
    }
  },

  "transformation": {
    "title": "Transformation operators",
    "description": "<b>RxJS transformation operators</b> are tools that let you change (or 'transform') the data that flows through an observable stream. Imagine you have a stream of values, like numbers or objects, and you want to modify, filter, or reshape these values before they reach the final observer.'",
    "shortDescription": "RxJS transformation operators are tools for modifying the data flowing through an observable.",
    "buffer": {
      "title": "Operator buffer",
      "description": "<p>The <b>buffer</b> operator in RxJS collects emissions from a source observable into an array and delivers them together when another observable, known as the <b>trigger</b>, emits a value. It is useful for grouping values over time intervals or in response to events.</p><p>In this example, we count the clicks made on a button every 3 seconds.</p>"
    },
    "bufferCount": {
      "title": "Operator bufferCount",
      "description": "<p>The <b>bufferCount</b> operator in RxJS is used to group emissions from an observable into 'buffers' or <b>fixed-size</b> batches and emit them as an array.</p><p>In this example, we will emit the array after making 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operator bufferTime",
      "description": "<p>The <b>bufferTime</b> operator in RxJS groups the emissions of an observable over a <b>fixed period of time</b> and emits them together as an array.</p><p>In this example, we display the array generated by the interval emission every 3 seconds.</p>"
    },
    "bufferToogle": {
      "title": "Operator bufferToogle",
      "description": "<p>The <b>bufferToggle</b> operator in RxJS allows you to collect values emitted by an observable into buffers (arrays) and emit those buffers based on signals from other observables. It works by opening and closing buffers based on events triggered by <b>opening and closing</b> observables.</p><p>In this example, we will capture the values emitted at 1-second intervals from the moment we press 'Start' until we press 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operator bufferWhen",
      "description": "<p>The <b>bufferWhen</b> operator in RxJS allows you to collect values emitted by a source observable into 'buffers' (arrays) and emit those buffers when <b>a condition is met</b>. The condition for closing each buffer is defined by a function that returns an observable. When this observable emits a value, the buffer is closed, and a new one begins.</p><p>In this example, we will capture the values emitted by a 1-second interval each time we click the button.</p>"
    },
    "concatMap": {
      "title": "Operator concatMap",
      "description": "<p>The <b>concatMap</b> operator in RxJS is used to queue up observables one after another, ensuring they run in sequence. When concatMap receives a value, it maps that value to a new observable (like a network request or a timer) and waits for it to complete before moving to the next one.<p><p>In this example, we merge the observable from a button click with the observable from an interval. Each time we click the button, we can see in the console how the observables are concatenated in an orderly manner, respecting their sequence.</p>"
    },
    "exhaustMap": {
      "title": "Operator exhaustMap",
      "description": "<p>The <b>exhaustMap</b> operator in RxJS is used to handle <b>asynchronous data streams</b>, ensuring that <b>only one operation is processed at a time</b> and ignoring any new actions while the current operation is still in progress.</p><p>In this example, we load a list of users through a button click. You can observe how the list will not load until the previous call has finished.</p>"
    },
    "expand": {
      "title": "Operator expand",
      "description": "<p>The <b>expand</b> operator in RxJS is used to generate a stream of values <b>recursively</b>, meaning it allows each emitted value to <b>generate new values</b> based on a defined logic.</p><p>In this example, we add 10 to each emitted value and repeat the operation 5 times.</p>"
    },
    "groupBy": {
      "title": "Operator groupBy",
      "description": "<p>The <b>groupBy</b> operator in RxJS is used to group elements emitted by an observable <b>based on a key</b> that you define. Think of it as a way to separate a data stream into different 'boxes' based on certain characteristics.</p><p>In this example, we group the species into different arrays, through a mergeMap and a toArray.</p>"
    },
    "map": {
      "title": "Operator map",
      "description": "<p>The <b>map</b> operator in RxJS applies a function to each value emitted by an observable and returns an observable that emits the transformed values.<p><p>In this example, we transform the user's name using the map operator and use the array's map method to update the name of each item within it.</p>"
    },
    "mapTo": {
      "title": "Operator mapTo",
      "description": "<p>The <b>mapTo</b> operator in RxJS replaces each value emitted by an observable with a specific value you provide.</p><p>In this example, with the mapTo operator, we replace all values from the observable with the value <b>strawberry</b>.</p>"
    },
    "mergeMap": {
      "title": "Operator mergeMap",
      "description": "<p>The <b>mergeMap</b> operator in RxJS is used to transform the values emitted by an observable into other observables and then <b>'flattens'</b> or combines all those emissions into a single data stream. This is useful when you want to perform multiple asynchronous operations in sequence and combine their results.</p><p>In this example, we merge an observable made up of a list of letters with an observable containing a numeric range from 1 to 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operator mergeMapTo",
      "description": "<p>The <b>mergeMapTo</b> operator in RxJS is used to replace each value emitted by an observable with a different observable that you specify, and it then 'flattens' all the results into a single output stream.</p><p>In this example, we merge an observable made up of a list of letters with an observable containing a numeric range from 1 to 2. <b>Unlike mergeMap</b>, we don`t take into account the output of the first observable, emitting the <b>same value</b> for each letter.</p>"
    },
    "mergeScan": {
      "title": "Operator mergeScan",
      "description": "<p>The RxJS <b>mergeScan</b> operator is like a combination of a <b>reduce</b> and a <b>mergeMap</b>, but it is applied to a stream of data (an observable) instead of a static collection like an array. It is used when you want to maintain an accumulative state as values are emitted from an observable, while simultaneously generating new observables from each emitted value.</p><p>In this example, we cumulatively sum the numbers from the observable.</p>"
    },
    "pairwise": {
      "title": "Operator pairwise",
      "description": "<p>The RxJS <b>pairwise</b> operator is a simple operator that groups consecutive values emitted by an observable into <b>pairs</b>. Each time the observable emits a new value, this operator takes the <b>previous and the current</b> values and combines them into a two-element array.</p><p>In this example, we can see how the last two emitted values are concatenated into an array.</p>"
    },
    "partition": {
      "title": "Operator partition",
      "description": "<p>The RxJS <b>partition</b> operator is a simple way to split a stream of data (observable) into two parts based on a condition. Essentially, it separates the emitted values into two different observables:</p><p>- <b>One observable</b> for the values that meet the condition.</p><p>- <b>Another observable</b> for the values that do not meet the condition.</p><p>In this example, we group the animals into two categories, those that are cats and those that are not.</p>"
    },
    "pluck": {
      "title": "Operator pluck",
      "description": "<p>The RxJS <b>pluck</b> operator is a simple way to extract a specific value from an object emitted by an observable. Essentially, it works like directly accessing a property by its <b>name</b>, but within the context of a data stream.</p><p>In this example, we will log the names of the animals from our observable to the console.</p>"
    },
    "scan": {
      "title": "Operator scan",
      "description": "<p>The <b>scan</b> operator in RxJS is very similar to the <b>reduce function of arrays</b>, but it applies to data streams. Essentially, it accumulates a value over time as new values arrive in the stream.</p><p>In this example, we cumulatively sum the values of the observable.</p>"
    },
    "switchMap": {
      "title": "Operator switchMap",
      "description": "<p>The <b>switchMap</b> operator in RxJS is used to switch from one observable to a new one whenever a new value is emitted by the original observable. When this happens, switchMap <b>cancels (or 'unsubscribes' from)</b> the previous observable and only listens to the latest one.</p>In this example, we merge the observable from a button click with the observable from an interval. Each time we click the button, we can see in the console how the previous observable is canceled.<p>"
    },
    "window": {
      "title": "Operator window",
      "description": "<p>The RxJS <b>window</b> operator divides a data stream (observable) into <b>sub-observables</b>, called <b>'windows'</b>. Each window groups the elements emitted by the original stream according to a defined criterion and closes when a specific event occurs.</p><p>In this example, we group numbers into 'windows' of three.</p>"
    },
    "windowCount": {
      "title": "Operator windowCount",
      "description": "<p>The RxJS <b>windowCount</b> operator divides a data stream (observable) into sub-observables (windows) based on a <b>fixed number</b> of emissions. In other words, each 'window' groups a specific number of emitted values.</p><p>In this example, we group numbers into 'windows' of three starting every 2 values.</p>"
    },
    "windowTime": {
      "title": "Operator windowTime",
      "description": "<p>The RxJS <b>windowTime</b> operator divides a data stream (observable) into <b>'fixed-time windows'</b>. Each window is a sub-observable that groups the values emitted during a specific time interval.</p><p>In this example, we group the values emitted by the interval into 3-second windows.</p>"
    },
    "windowToogle": {
      "title": "Operator windowToogle",
      "description": "<p>The RxJS <b>windowToggle</b> operator divides a data stream (observable) into windows that open and close based on two observables:</p><p><b>- Opener (openings)</b>: An observable that indicates when to open a new window.</p><p><b>- Closer (closings)</b>: A function that generates an observable to decide when to close the window.</p><p>In this example, we emit the values from the interval, opening a new window every 5 seconds and closing it after 3 seconds.</p>"
    },
    "windowWhen": {
      "title": "Operator windowWhen",
      "description": "<p>The RxJS <b>windowWhen</b> operator divides a data stream (observable) into windows that <b>close and open</b> based on a custom criterion. You decide when a window should close and a new one should open using a function that generates observables.</p><p>In this example, we emit values from an interval that opens and closes every 3 seconds.</p>"
    }
  }
}
