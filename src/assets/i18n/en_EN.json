{
  "english": "English",
  "spanish": "Spanish",
  "transformation": {
    "title": "Transformation operators",
    "description": "<b>RxJS transformation operators</b> are tools that let you change (or 'transform') the data that flows through an observable stream. Imagine you have a stream of values, like numbers or objects, and you want to modify, filter, or reshape these values before they reach the final observer.'",
    "shortDescription": "RxJS transformation operators are tools for modifying the data flowing through an observable.",
    "buffer": {
      "title": "Operator buffer",
      "description": "<p>The buffer operator in RxJS collects emissions from a source observable into an array and delivers them together when another observable, known as the <b>trigger</b>, emits a value. It is useful for grouping values over time intervals or in response to events.</p><p>In this example, we count the clicks made on a button every 3 seconds.</p>"
    },
    "bufferCount": {
      "title": "Operator bufferCount",
      "description": "<p>The bufferCount operator in RxJS is used to group emissions from an observable into 'buffers' or <b>fixed-size</b> batches and emit them as an array.</p><p>In this example, we will emit the array after making 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operator bufferTime",
      "description": "<p>The bufferTime operator in RxJS groups the emissions of an observable over a <b>fixed period of time</b> and emits them together as an array.</p><p>In this example, we display the array generated by the interval emission every 3 seconds.</p>"
    },
    "bufferToogle": {
      "title": "Operator bufferToogle",
      "description": "<p>The bufferToggle operator in RxJS allows you to collect values emitted by an observable into buffers (arrays) and emit those buffers based on signals from other observables. It works by opening and closing buffers based on events triggered by <b>opening and closing</b> observables.</p><p>In this example, we will capture the values emitted at 1-second intervals from the moment we press 'Start' until we press 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operator bufferWhen",
      "description": "<p>The bufferWhen operator in RxJS allows you to collect values emitted by a source observable into 'buffers' (arrays) and emit those buffers when <b>a condition is met</b>. The condition for closing each buffer is defined by a function that returns an observable. When this observable emits a value, the buffer is closed, and a new one begins.</p><p>In this example, we will capture the values emitted by a 1-second interval each time we click the button.</p>"
    },
    "map": {
      "title": "Operator map",
      "description": "<p>The map operator in RxJS applies a function to each value emitted by an observable and returns an observable that emits the transformed values.<p><p>In this example, we transform the user's name using the map operator and use the array's map method to update the name of each item within it.</p>"
    },
    "mapTo": {
      "title": "Operator mapTo",
      "description": "<p>The mapTo operator in RxJS replaces each value emitted by an observable with a specific value you provide.</p><p>In this example, with the mapTo operator, we replace all values from the observable with the value <b>strawberry</b>.</p>"
    },
    "mergeMap": {
      "title": "Operator mergeMap",
      "description": "<p>The mergeMap operator in RxJS is used to transform the values emitted by an observable into other observables and then <b>'flattens'</b> or combines all those emissions into a single data stream. This is useful when you want to perform multiple asynchronous operations in sequence and combine their results.</p><p>In this example, we merge an observable made up of a list of letters with an observable containing a numeric range from 1 to 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operator mergeMapTo",
      "description": "<p>The mergeMapTo operator in RxJS is used to replace each value emitted by an observable with a different observable that you specify, and it then 'flattens' all the results into a single output stream.</p><p>In this example, we merge an observable made up of a list of letters with an observable containing a numeric range from 1 to 2. <b>Unlike mergeMap</b>, we don`t take into account the output of the first observable, emitting the <b>same value</b> for each letter.</p>"
    },
    "switchMap": {
      "title": "Operator switchMap",
      "description": "<p>The switchMap operator in RxJS is used to switch from one observable to a new one whenever a new value is emitted by the original observable. When this happens, switchMap <b>cancels (or 'unsubscribes' from)</b> the previous observable and only listens to the latest one.</p>In this example, we merge the observable from a button click event with an observable created using an interval. We cancel the resulting observable when the stop button is clicked using the takeUntil operator. Each time we click the start button, we can see in the console how the previous observable is canceled.<p>"
    },
    "concatMap": {
      "title": "Operator concatMap",
      "description": "<p>The concatMap operator in RxJS is used to queue up observables one after another, ensuring they run in sequence. When concatMap receives a value, it maps that value to a new observable (like a network request or a timer) and waits for it to complete before moving to the next one.<p><p>In this example, we merge the observable from a button click event with the observable created using an interval. We cancel the resulting observable when we click the stop button using the takeUntil operator. Each time we click the start button, we can see in the console how the observables are concatenated in an orderly manner, respecting their sequence.</p>"
    }
  }
}
