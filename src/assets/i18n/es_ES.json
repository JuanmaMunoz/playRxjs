{
  "english": "Inglés",
  "spanish": "Español",
  "combination": {
    "title": "Operadores de Combinación",
    "description": "<b>Los operadores de combinación en RxJS</b> permiten trabajar con múltiples observables para <b>combinarlos</b> y <b>crear nuevos</b> flujos de datos de manera flexible. Cada operador tiene un propósito específico dependiendo de cómo deseas combinar los valores de los observables.",
    "shortDescription": "Los operadores de combinación son herramientas clave para gestionar flujos de datos en tiempo real o flujos asincrónicos.",
    "combineLatest": {
      "title": "Operador combineLatest",
      "description": "<p>El operador combineLatest en RxJS es una forma de combinar múltiples observables en uno solo, de modo que cada vez que uno de ellos emite un valor, se emite un nuevo conjunto de valores que contiene:</p>- El valor <b>más reciente</b> de todos los observables involucrados.</p><p>- <b>Todos</b> los valores del último observable.</p>"
    }
  },

  "transformation": {
    "title": "Operadores de transformación",
    "description": "<b>Los operadores de transformación de RxJS</b> son herramientas que te permiten cambiar (o 'transformar') los datos que fluyen a través de un flujo observable. Imagina que tienes un flujo de valores, como números u objetos, y quieres modificar, filtrar o reestructurar estos valores antes de que lleguen al observador final.",
    "shortDescription": "Los operadores de transformación de RxJS son herramientas para modificar los datos que fluyen por un observable.",
    "buffer": {
      "title": "Operador buffer",
      "description": "<p>El operador buffer de RxJS recopila las emisiones de un observable fuente en un array y las entrega juntas cuando otro observable, conocido como <b>disparador</b> (trigger), emite un valor. Es útil para agrupar valores durante intervalos de tiempo o en respuesta a eventos.<p><p>En este ejemplo contabilizamos los clicks que se hace en un botón cada 3 segundos.</p> "
    },
    "bufferCount": {
      "title": "Operador bufferCount",
      "description": "<p>El operador bufferCount de RxJS se utiliza para agrupar emisiones de un observable en 'buffers' o lotes de tamaño <b>fijo</b> y emitirlos como un array.</p><p>En este ejemplo emitiremos el array al hacer 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operador bufferTime",
      "description": "<p>El operador bufferTime de RxJS agrupa las emisiones de un observable durante un período de <b>tiempo fijo</b> y las emite juntas como un array.</p><p>En este ejemplo, mostramos el array que se genera con la emisión del intervalo cada 3 segundos.</p>"
    },
    "bufferToogle": {
      "title": "Operador bufferToogle",
      "description": "<p>El operador bufferToggle de RxJS te permite recolectar valores emitidos por un observable en buffers (arreglos) y emitir esos buffers en función de señales provenientes de otros observables. Funciona abriendo y cerrando buffers basados en eventos disparados por observables de <b>apertura y cierre</b>.</p><p>En este ejemplo capturaremos los valores emitidos en un intervalo de 1 segundo desde que presionemos 'Start' hasta que presionemos 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operador bufferWhen",
      "description": "<p>El operador bufferWhen de RxJS permite recolectar valores emitidos por un observable fuente en 'buffers' (arreglos) y emitir esos buffers cuando <b>se cumple una condición</b>. La condición para cerrar cada buffer se define a través de una función que devuelve un observable. Cuando este observable emite un valor, el buffer se cierra y se inicia uno nuevo.</p><p>En este ejemplo capturaremos los valores emitidos por un intervalo de 1 segundo, cada vez que hagamos click en el botón.</p>"
    },
    "concatMap": {
      "title": "Operador concatMap",
      "description": "<p>El operador concatMap en RxJS se utiliza para encadenar observables uno tras otro, asegurándose de que se ejecuten en secuencia. Cuando concatMap recibe un valor, lo mapea a un nuevo observable (como una solicitud de red o un temporizador) y espera a que este se complete antes de pasar al siguiente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic, podemos ver en la consola cómo los observables se concatenan de manera ordenada, respetando su secuencia.</p>"
    },
    "exhaustMap": {
      "title": "Operador exhaustMap",
      "description": "<p>El operador exhaustMap en RxJS sirve para manejar flujos de datos <b>asincrónicos</b> asegurándote de que solo procese <b>una operación a la vez</b> y que ignore cualquier nueva acción mientras la operación actual sigue en curso.</p><p>En este ejemplo cargamos una lista de usuarios a través del clic de un botón. Podremos comprobar como no se carga la lista hasta que la llamada previa haya finalizado.</p>"
    },
    "expand": {
      "title": "Operador expand",
      "description": "<p>El operador expand en RxJS se utiliza para generar un flujo de valores de manera <b>recursiva</b>, es decir, permite que cada valor emitido pueda <b>generar nuevos valores</b> basados en una lógica definida.</p><p>En este ejemplo, a cada valor emitido le sumamos 10 hasta repetir 5 veces la operación.</p>"
    },
    "groupBy": {
      "title": "Operador groupBy",
      "description": "<p>El operador groupBy de RxJS se utiliza para agrupar elementos emitidos por un observable <b>según una clave</b> que tú defines. Piensa en él como una forma de separar un flujo de datos en diferentes 'cajones' según alguna característica.</p><p>En este ejemplo agrupamos las especies en diferentes arreglos, a través de un mergeMap y un toArray.</p>"
    },
    "map": {
      "title": "Operador map",
      "description": "<p>El operador map en RxJS aplica una función a cada valor emitido por un observable y devuelve un observable que emite los valores transformados.</p><p>En este ejemplo, transformamos el nombre del usuario utilizando el operador map y usamos el método map del arreglo para actualizar el nombre de cada elemento dentro de él.</p>"
    },
    "mapTo": {
      "title": "Operador mapTo",
      "description": "<p>El operador mapTo en RxJS reemplaza cada valor emitido por un observable con un valor específico que proporcionas.</p><p>En este ejemplo, con el operador mapTo, reemplazamos todos los valores del observable con el valor <b>fresa</b>.</p>"
    },
    "mergeMap": {
      "title": "Operador mergeMap",
      "description": "<p>El operador mergeMap en RxJS se utiliza para transformar los valores emitidos por un observable en otros observables y luego <b>'aplana'</b> o combina todas esas emisiones en un único flujo de datos. Esto es útil cuando deseas realizar múltiples operaciones asíncronas en secuencia y combinar sus resultados.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operador mergeMapTo",
      "description": "<p>El operador mergeMapTo en RxJS se utiliza para reemplazar cada valor emitido por un observable con un observable diferente que especifiques, y luego 'aplana' todos los resultados en un único flujo de salida.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2. <b>A diferencia de mergeMap</b>, no tomamos en cuenta la salida del primer observable, emitiendo el <b>mismo valor</b> para cada letra.</p>"
    },
    "mergeScan": {
      "title": "Operador mergeScan",
      "description": "<p>El operador mergeScan de RxJS es como una combinación de un <b>reduce</b> y un <b>mergeMap</b>, pero se aplica a un flujo de datos (un observable) en lugar de a una colección estática como un array. Se utiliza cuando quieres mantener un estado acumulativo a medida que se emiten valores de un observable, y al mismo tiempo generar nuevos observables a partir de cada valor emitido.</p><p>En este ejemplo sumamos de forma acomulativa los números del obersevable.</p>"
    },
    "pairwise": {
      "title": "Operador pairwise",
      "description": "<p>El operador pairwise de RxJS es un operador simple que agrupa los valores consecutivos emitidos por un observable en <b>pares</b>. Cada vez que el observable emite un nuevo valor, este operador toma el valor <b>anterior y el actual</b> y los combina en un array de dos elementos.</p><p>En este ejemplo podemos comprobar como se van concatenando en un array los dos últimos valores emitidos.</p>"
    },
    "partition": {
      "title": "Operador partition",
      "description": "<p>El operador partition de RxJS es una forma sencilla de dividir un flujo de datos (observable) en dos partes, según una condición. Básicamente, separa los valores emitidos en dos observables diferentes:</p><p>- <b>Un observable</b> para los valores que cumplen con la condición.</p><p>- <b>Otro observable</b> para los valores que no la cumplen.</p><p>En este ejemplo agrupamos los animales en dos grupos, los que son gatos y los que no lo son.</p>"
    },
    "pluck": {
      "title": "Operador pluck",
      "description": "<p>El operador pluck de RxJS es una forma sencilla de extraer un valor específico de un objeto emitido por un observable. Básicamente, es como acceder a una propiedad directamente usando su <b>nombre</b>, pero en el contexto de un flujo de datos.</p><p>En este ejemplo vamos a mostrar por consola los nombres de los animales de nuestro observable.</p>"
    },
    "scan": {
      "title": "Operador scan",
      "description": "<p>El operador scan de RxJS es muy similar a la función <b>reduce de los arreglos</b>, pero se aplica a flujos de datos (streams). Básicamente, acumula un valor a lo largo del tiempo, a medida que van llegando nuevos valores al flujo.</p><p>En este ejemplo sumamos de forma acumulativa los valores del observable.</p>"
    },
    "switchMap": {
      "title": "Operador switchMap",
      "description": "<p>El operador switchMap en RxJS se utiliza para cambiar de un observable a uno nuevo cada vez que el observable original emite un nuevo valor. Cuando esto ocurre, switchMap <b>cancela (o 'se desuscribe de')</b> el observable anterior y solo escucha al más reciente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic en el botón, podemos ver en la consola cómo se cancela el observable anterior.</p>"
    },
    "window": {
      "title": "Operador window",
      "description": "<p>El operador window de RxJS divide un flujo de datos (observable) en <b>sub-observables</b>, llamados <b>'ventanas'</b>. Cada ventana agrupa los elementos emitidos por el flujo original según un criterio definido, y se cierra cuando ocurre un evento determinado.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres</p>"
    },
    "windowCount": {
      "title": "Operador windowCount",
      "description": "<p>El operador windowCount de RxJS divide un flujo de datos (observable) en sub-observables (ventanas) basados en un <b>número fijo</b> de emisiones. Es decir, cada 'ventana' agrupa una cantidad específica de valores emitidos.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres comenzando cada 2 valores.</p>"
    },
    "windowTime": {
      "title": "Operador windowTime",
      "description": "<p>El operador windowTime de RxJS divide un flujo de datos (observable) en <b>'ventanas' de tiempo fijo</b>. Cada ventana es un sub-observable que agrupa los valores emitidos durante un intervalo de tiempo determinado.</p><p>En este ejemplo agrupamos los valores emitidos por el intervalo en ventanas de 3 segundos.</p>"
    },
    "windowToogle": {
      "title": "Operador windowToogle",
      "description": "<p>El operador windowToggle de RxJS divide un flujo de datos (observable) en ventanas que se abren y cierran según dos observables:</p><p><b>- Abridor (openings)</b>: Un observable que indica cuándo abrir una nueva ventana.</p><p>- <b>Cierre (closings)</b>: Una función que genera un observable para decidir cuándo cerrar esa ventana.</p><p>En este ejemplo emitimos los valores del intervalo abriendo una nueva ventana cada 5 segundos y cerrándola cada 3 segundos.</p>"
    },
    "windowWhen": {
      "title": "Operador windowWhen",
      "description": "<p>El operador windowWhen de RxJS divide un flujo de datos (observable) en ventanas que se <b>cierran y abren</b> según un criterio personalizado. Tú decides cuándo una ventana debe cerrarse y una nueva debe abrirse usando una función que genera observables.</p><p>En este ejemplo emitimos valores de un intervalo que se abre y cierra cada 3 segundos.</p>"
    }
  }
}
