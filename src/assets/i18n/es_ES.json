{
  "english": "Inglés",
  "spanish": "Español",
  "combination": {
    "title": "Operadores de combinación",
    "description": "<b>Los operadores de combinación en RxJS</b> permiten trabajar con múltiples observables para <b>combinarlos</b> y <b>crear nuevos</b> flujos de datos de manera flexible. Cada operador tiene un propósito específico dependiendo de cómo deseas combinar los valores de los observables.",
    "shortDescription": "Los operadores de combinación son herramientas clave para gestionar flujos de datos en tiempo real o flujos asincrónicos.",
    "combineLatest": {
      "title": "Operador combineLatest",
      "description": "<p>El operador <b>combineLatest</b> en RxJS es una forma de combinar múltiples observables en uno solo, emitiendo el <b>último valor</b> de cada uno de ellos con la <b>secuencia de valores</b> del último observable.</p>"
    },
    "concat": {
      "title": "Operador concat",
      "description": "<p>El operador <b>concat</b> en RxJS combina varios observables de manera secuencial, emitiendo los valores de <b>uno hasta que se complete</b>, y luego pasa al <b>siguiente</b>.</p>"
    },
    "concatAll": {
      "title": "Operador concatAll",
      "description": "<p>El operador <b>concatAll</b> en RxJS se utiliza para <b>'aplanar'</b> un flujo de observables de manera secuencial. Esto significa que si tienes un observable que emite otros observables, concatAll toma esos observables y los emite <b>uno por uno</b>, en el orden en que fueron emitidos, esperando a que cada uno termine antes de pasar al siguiente.</p>"
    },
    "exhaust": {
      "title": "Operador exhaust",
      "description": "<p>El operador <b>exhaust</b> en RxJS se utiliza para manejar flujos de observables de manera que, cuando un observable fuente emite un nuevo observable, el operador <b>solo escuchará al primer</b> observable y se ignorarán los nuevos observables emitidos hasta que el <b>primero termine</b>. En otras palabras, si el observable fuente sigue emitiendo observables, pero ya está 'trabajando' con uno, esos nuevos observables no serán escuchados hasta que el anterior termine.</p><p>En este ejmplo podemos comprobar como el delay del segundo observable impide que se ejecute el tercer observable.</p>"
    },
    "forkJoin": {
      "title": "Operador forkJoin",
      "description": "<p>El operador <b>forkJoin</b> en RxJS se utiliza para esperar a que todos los observables que se le pasen como argumentos <b>terminen</b> y, cuando todos hayan emitido su último valor, emite un solo <b>array con los últimos valores</b> de cada uno de esos observables.</p>"
    },
    "merge": {
      "title": "Operador merge",
      "description": "<p>El operador <b>merge</b> en RxJS se utiliza para combinar múltiples observables y emitir sus valores de manera <b>intercalada</b> (sin esperar a que uno termine antes de escuchar el siguiente). Los valores se emiten en el <b>mismo orden</b> en que los observables los producen, y todos los observables se suscriben y se ejecutan <b>simultáneamente</b>.</p>"
    },
    "mergeAll": {
      "title": "Operador mergeAll",
      "description": "<p>El operador <b>mergeAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de manera <b>diferente</b> a otros operadores como <b>concatAll</b>. Con mergeAll, cuando un observable emite otros observables, <b>todos</b> los observables se suscriben y se ejecutan de manera <b>simultánea</b>.</p>"
    },
    "race": {
      "title": "Operador race",
      "description": "<p>El operador <b>race</b> en RxJS se utiliza para <b>competir</b> entre varios observables y emitir los valores del <b>primer observable que emita algo</b>. Es decir, de todos los observables que se le pasen, el operador se suscribe solo al que primero emita un valor, y <b>descarta</b> los demás observables.</p>"
    },
    "startWith": {
      "title": "Operador startWith",
      "description": "<p>El operador <b>startWith</b> en RxJS se utiliza para emitir un <b>valor inicial antes</b> de que cualquier otro valor sea emitido por el observable. Es decir, puedes especificar un valor que se emitirá al principio, antes de que el observable comience a emitir sus propios valores.</p>"
    },
    "switchAll": {
      "title": "Operador switchAll",
      "description": "<p>El operador <b>switchAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de una manera especial: cuando un observable emite un <b>nuevo observable</b>, switchAll <b>deja de escuchar</b> al observable anterior y comienza a escuchar al nuevo observable. Es decir, siempre se suscribe solo al <b>último observable(s) emitido(s)</b> y cancela la suscripción a los anteriores.</p>"
    },
    "withLatestFrom": {
      "title": "Operador withLatestFrom",
      "description": "<p>El operador <b>withLatestFrom</b> en RxJS se utiliza para combinar el valor <b>más reciente</b> de un observable con los valores de otro observable, <b>sin suscribirse al segundo observable</b>. Esto significa que cuando el primer observable emite un valor, withLatestFrom toma el valor más reciente del segundo observable y lo combina con el valor emitido por el primer observable.</p>"
    }
  },

  "conditional": {
    "title": "Operadores condicionales",
    "description": "<b>Los operadores condicionales en RxJS</b> se utilizan para manejar flujos de datos de manera <b>condicional</b>, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "shortDescription": "Los operadores condicionales en RxJS se utilizan para manejar flujos de datos de manera condicional, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "defaultIfEmpty": {
      "title": "Operador defaultIfEmpty",
      "description": "<p>El operador <b>defaultIfEmpty</b> en RxJS se utiliza para proporcionar un <b>valor por defecto</b> cuando un observable <b>no emite ningún valor</b>. Es decir, si el observable está vacío (no emite nada), defaultIfEmpty emite el valor que especifiques como predeterminado.</p>"
    },
    "every": {
      "title": "Operador every",
      "description": "<p>El operador <b>every</b> en RxJS se utiliza para comprobar si todos los valores emitidos por un observable <b>cumplen con una condición específica</b>. Devuelve un observable que <b>emite true</b> si todos los valores emitidos cumplen la condición, y <b>false</b> si al menos uno de los valores no la cumple.</p>"
    },
    "find": {
      "title": "Operador find",
      "description": "<p>El operador <b>find</b> en RxJS se utiliza para buscar el <b>primer valor</b> que cumpla con una condición específica en un observable. A diferencia de otros operadores como <b>filter</b>, que emite <b>todos</b> los valores que cumplen la condición, find devuelve solo el primer valor que cumple la condición o undefined si ningún valor lo cumple.</p>"
    },
    "findIndex": {
      "title": "Operador findIndex",
      "description": "<p>El operador <b>findIndex</b> en RxJS es muy parecido al operador find, pero en lugar de devolver el primer valor que cumple con una condición, <b>devuelve el índice</b> de ese valor. Si ningún valor cumple la condición, devuelve <b>-1</b>.</p>"
    },
    "isEmpty": {
      "title": "Operador isEmpty",
      "description": "<p>El operador <b>isEmpty</b> en RxJS se utiliza para verificar si un observable <b>no emite ningún valor</b>. Devuelve un observable que emite:</p><p>- <b>true</b> si el observable no emite ningún valor.</p><p>- <b>false</b> si el observable emite al menos un valor.<p>"
    },
    "sequenceEqual": {
      "title": "Operador sequenceEqual",
      "description": "<p>El operador <b>sequenceEqual</b> en RxJS se utiliza para comprobar si <b>dos observables</b> emiten exactamente <b>la misma secuencia de valores, en el mismo orden</b>.</p>"
    }
  },

  "creation": {
    "title": "Operadores de creación",
    "description": "<b>En RxJS, los operadores de creación</b> son funciones que <b>generan observables</b> desde cero o a partir de otros valores o estructuras. Estos operadores permiten crear flujos de datos que luego pueden ser procesados.",
    "shortDescription": "En RxJS, los operadores de creación son funciones que generan observables desde cero o a partir de otros valores o estructuras.",
    "ajax": {
      "title": "Operador ajax",
      "description": "<p>El operador <b>ajax</b> de RxJS es una utilidad para <b>realizar solicitudes HTTP</b> (como GET, POST, PUT, DELETE) de manera sencilla y manejar las respuestas en forma de observables. Es ideal para trabajar con datos que provienen de APIs.</p>"
    },
    "defer": {
      "title": "Operador defer",
      "description": "<p>El operador <b>defer</b> en RxJS es como una <b>'fábrica de observables'</b>. Su propósito principal es crear un <b>nuevo observable</b> cuando alguien se <b>suscribe</b>, en lugar de hacerlo inmediatamente. Esto permite que el observable se genere bajo demanda, asegurándose de que siempre se ejecute con la lógica o datos más actualizados.</p>"
    },
    "from": {
      "title": "Operador from",
      "description": "<p>El operador <b>from</b> es como un puente entre estructuras comunes de JavaScript y el mundo reactivo de RxJS. Convierte cosas como <b>arrays y promesas en observables</b> que puedes usar en tus flujos reactivos.</p>"
    },
    "fromEvent": {
      "title": "Operador fromEvent",
      "description": "<p>El operador <b>fromEvent</b> de RxJS convierte un <b>evento en un observable</b>. Esto significa que puedes escuchar eventos, como clics del ratón, movimientos del cursor, teclas presionadas, y trabajar con ellos como flujos de datos.</p>"
    },
    "generate": {
      "title": "Operador generate",
      "description": "<p>El operador <b>generate</b> de RxJS es una forma avanzada de <b>crear observables</b> que emiten una secuencia de valores basada en una <b>función generadora</b>. Permite generar un flujo de datos personalizado mediante la especificación de condiciones de inicio, continuación y actualización de los valores que se emiten.</p>"
    },
    "iif": {
      "title": "Operador iif",
      "description": "<p>El operador <b>iif</b> en RxJS es una forma de crear un observable condicional. En otras palabras, iif te permite <b>decidir</b> qué observable emitir en función de una condición.</p>"
    },
    "interval": {
      "title": "Operador interval",
      "description": "<p>El operador <b>interval</b> de RxJS <b>crea</b> un observable que emite <b>valores numéricos</b> de manera continua, comenzando desde 0, y luego incrementando cada vez después de un intervalo de tiempo específico.</p>"
    },
    "of": {
      "title": "Operador of",
      "description": "<p>El operador <b>of</b> de RxJS crea un observable a partir de un conjunto de valores que le pases. Estos valores pueden ser <b>cualquier tipo de dato</b>, como números, cadenas, objetos, etc.</p>"
    },
    "range": {
      "title": "Operador range",
      "description": "<p>El operador <b>range</b> de RxJS crea un observable que emite una secuencia de números dentro de un rango especificado, comenzando desde un valor <b>inicial</b> y hasta un valor <b>final</b>.</p>"
    },
    "throwError": {
      "title": "Operador throwError",
      "description": "<p>El operador <b>throwError</b> de RxJS se utiliza para <b>emitir un error</b> en un observable de manera manual. Esto es útil cuando deseas que un flujo de datos se detenga debido a una condición específica y que se maneje un error.</p>"
    },
    "timer": {
      "title": "Operador timer",
      "description": "<p>El operador <b>timer</b> de RxJS crea un observable que emite un valor <b>después de un cierto período de tiempo</b> (en milisegundos) y luego puede seguir emitiendo valores a intervalos regulares si se le indica.</p>"
    }
  },

  "mathematical": {
    "title": "Operadores matemáticos",
    "description": "<b>Los operadores matemáticos en RxJS</b> se utilizan para realizar cálculos y <b>transformaciones matemáticas</b> en los valores emitidos por un observable. Estos operadores permiten sumar, promediar, o encontrar valores mínimos o máximos dentro de un flujo de datos.",
    "shortDescription": "Los operadores matemáticos en RxJS se utilizan para realizar cálculos y transformaciones matemáticas en los valores emitidos por un observable.",
    "count": {
      "title": "Operador count",
      "description": "<p>El operador <b>count</b> en RxJS se utiliza para contar la <b>cantidad de valores</b> emitidos por un observable <b>que cumplen con una condición específica</b>. Si no se proporciona una condición, cuenta todos los valores emitidos.</p>"
    },
    "max": {
      "title": "Operador max",
      "description": "<p>El operador <b>max</b> en RxJS se utiliza para encontrar el <b>valor máximo</b> emitido por un observable. Este operador compara todos los valores emitidos y devuelve el que sea el más alto.</p>"
    },
    "min": {
      "title": "Operador min",
      "description": "<p>El operador <b>min</b> en RxJS se utiliza para encontrar el <b>valor mínimo</b> emitido por un observable. Este operador compara todos los valores emitidos y devuelve el que sea el más bajo.</p>"
    },
    "reduce": {
      "title": "Operador reduce",
      "description": "<p>El operador <b>reduce</b> en RxJS se utiliza para <b>acumular los valores emitidos</b> por un observable, similar a cómo funciona reduce en los arrays de JavaScript. Toma todos los valores emitidos y los va combinando en un solo valor final.</p>"
    }
  },
  "multicasting": {
    "title": "Operadores de multidifusión",
    "description": "Los <b>operadores de multidifusión en RxJS</b> se utilizan para compartir <b>un solo flujo de valores</b> entre múltiples suscriptores, de modo que los valores emitidos por el observable no se repitan para cada suscriptor. Esto <b>optimiza el rendimiento</b> al evitar que los valores se emitan varias veces para cada suscriptor.",
    "shortDescription": "Los operadores de multidifusión en RxJS se utilizan para compartir un solo flujo de valores entre múltiples suscriptores, de modo que los valores emitidos por el observable no se repitan para cada suscriptor.",
    "connect": {
      "title": "Operador connect",
      "description": "<p>El operador <b>connect</b> en RxJS se utiliza para <b>ctivar</b> un observable que está configurado para ser compartido a través de un subject (usualmente con publish() o multicast()). Este operador permite que el observable comience a emitir valores solo después de que se llame a <b>connect()</b>, es decir, controla cuando el observable comienza a emitir valores.</p>"
    },
    "share": {
      "title": "Operador share",
      "description": "<p>El operador <b>share</b> en RxJS es una forma de multidifusión que permite que un <b>único flujo de datos</b> emitido por un observable sea compartido entre múltiples suscriptores, sin que cada suscriptor <b>reciba sus propias emisiones</b>. Esto evita que el observable sea ejecutado <b>más de una vez</b>, optimizando el rendimiento.</p>"
    },
    "shareReplay": {
      "title": "Operador shareReplay",
      "description": "<p>El operador <b>shareReplay</b> en RxJS es similar al operador share, pero con una diferencia clave: <b>mantiene en caché los últimos valores emitidos por el observable y los reproduce (replay) a nuevos suscriptores</b>. Es útil cuando quieres que los nuevos suscriptores reciban los últimos valores emitidos sin volver a ejecutar todo el flujo de datos.</p>"
    }
  },

  "transformation": {
    "title": "Operadores de transformación",
    "description": "<b>Los operadores de transformación de RxJS</b> son herramientas que te permiten cambiar (o 'transformar') los datos que fluyen a través de un flujo observable. Imagina que tienes un flujo de valores, como números u objetos, y quieres modificar, filtrar o reestructurar estos valores antes de que lleguen al observador final.",
    "shortDescription": "Los operadores de transformación de RxJS son herramientas para modificar los datos que fluyen por un observable.",
    "buffer": {
      "title": "Operador buffer",
      "description": "<p>El operador <b>buffer</b> de RxJS recopila las emisiones de un observable fuente en un array y las entrega juntas cuando otro observable, conocido como <b>disparador</b> (trigger), emite un valor. Es útil para agrupar valores durante intervalos de tiempo o en respuesta a eventos.<p><p>En este ejemplo contabilizamos los clicks que se hace en un botón cada 3 segundos.</p> "
    },
    "bufferCount": {
      "title": "Operador bufferCount",
      "description": "<p>El operador <b>bufferCount</b> de RxJS se utiliza para agrupar emisiones de un observable en 'buffers' o lotes de tamaño <b>fijo</b> y emitirlos como un array.</p><p>En este ejemplo emitiremos el array al hacer 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operador bufferTime",
      "description": "<p>El operador <b>bufferTime</b> de RxJS agrupa las emisiones de un observable durante un período de <b>tiempo fijo</b> y las emite juntas como un array.</p><p>En este ejemplo, mostramos el array que se genera con la emisión del intervalo cada 3 segundos.</p>"
    },
    "bufferToogle": {
      "title": "Operador bufferToogle",
      "description": "<p>El operador <b>bufferToggle</b> de RxJS te permite recolectar valores emitidos por un observable en buffers (arreglos) y emitir esos buffers en función de señales provenientes de otros observables. Funciona abriendo y cerrando buffers basados en eventos disparados por observables de <b>apertura y cierre</b>.</p><p>En este ejemplo capturaremos los valores emitidos en un intervalo de 1 segundo desde que presionemos 'Start' hasta que presionemos 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operador bufferWhen",
      "description": "<p>El operador <b>bufferWhen</b> de RxJS permite recolectar valores emitidos por un observable fuente en 'buffers' (arreglos) y emitir esos buffers cuando <b>se cumple una condición</b>. La condición para cerrar cada buffer se define a través de una función que devuelve un observable. Cuando este observable emite un valor, el buffer se cierra y se inicia uno nuevo.</p><p>En este ejemplo capturaremos los valores emitidos por un intervalo de 1 segundo, cada vez que hagamos click en el botón.</p>"
    },
    "concatMap": {
      "title": "Operador concatMap",
      "description": "<p>El operador <b>concatMap</b> en RxJS se utiliza para encadenar observables uno tras otro, asegurándose de que se ejecuten en secuencia. Cuando concatMap recibe un valor, lo mapea a un nuevo observable (como una solicitud de red o un temporizador) y espera a que este se complete antes de pasar al siguiente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic, podemos ver en la consola cómo los observables se concatenan de manera ordenada, respetando su secuencia.</p>"
    },
    "exhaustMap": {
      "title": "Operador exhaustMap",
      "description": "<p>El operador <b>exhaustMap</b> en RxJS sirve para manejar flujos de datos <b>asincrónicos</b> asegurándote de que solo procese <b>una operación a la vez</b> y que ignore cualquier nueva acción mientras la operación actual sigue en curso.</p><p>En este ejemplo cargamos una lista de usuarios a través del clic de un botón. Podremos comprobar como no se carga la lista hasta que la llamada previa haya finalizado.</p>"
    },
    "expand": {
      "title": "Operador expand",
      "description": "<p>El operador <b>expand</b> en RxJS se utiliza para generar un flujo de valores de manera <b>recursiva</b>, es decir, permite que cada valor emitido pueda <b>generar nuevos valores</b> basados en una lógica definida.</p><p>En este ejemplo, a cada valor emitido le sumamos 10 hasta repetir 5 veces la operación.</p>"
    },
    "groupBy": {
      "title": "Operador groupBy",
      "description": "<p>El operador <b>groupBy</b> de RxJS se utiliza para agrupar elementos emitidos por un observable <b>según una clave</b> que tú defines. Piensa en él como una forma de separar un flujo de datos en diferentes 'cajones' según alguna característica.</p><p>En este ejemplo agrupamos las especies en diferentes arreglos, a través de un mergeMap y un toArray.</p>"
    },
    "map": {
      "title": "Operador map",
      "description": "<p>El operador <b>map</b> en RxJS aplica una función a cada valor emitido por un observable y devuelve un observable que emite los valores transformados.</p><p>En este ejemplo, transformamos el nombre del usuario utilizando el operador map y usamos el método map del arreglo para actualizar el nombre de cada elemento dentro de él.</p>"
    },
    "mapTo": {
      "title": "Operador mapTo",
      "description": "<p>El operador <b>mapTo</b> en RxJS reemplaza cada valor emitido por un observable con un valor específico que proporcionas.</p><p>En este ejemplo, con el operador mapTo, reemplazamos todos los valores del observable con el valor <b>fresa</b>.</p>"
    },
    "mergeMap": {
      "title": "Operador mergeMap",
      "description": "<p>El operador <b>mergeMap</b> en RxJS se utiliza para transformar los valores emitidos por un observable en otros observables y luego <b>'aplana'</b> o combina todas esas emisiones en un único flujo de datos. Esto es útil cuando deseas realizar múltiples operaciones asíncronas en secuencia y combinar sus resultados.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operador mergeMapTo",
      "description": "<p>El operador <b>mergeMapTo</b> en RxJS se utiliza para reemplazar cada valor emitido por un observable con un observable diferente que especifiques, y luego 'aplana' todos los resultados en un único flujo de salida.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2. <b>A diferencia de mergeMap</b>, no tomamos en cuenta la salida del primer observable, emitiendo el <b>mismo valor</b> para cada letra.</p>"
    },
    "mergeScan": {
      "title": "Operador mergeScan",
      "description": "<p>El operador <b>mergeScan</b> de RxJS es como una combinación de un <b>reduce</b> y un <b>mergeMap</b>, pero se aplica a un flujo de datos (un observable) en lugar de a una colección estática como un array. Se utiliza cuando quieres mantener un estado acumulativo a medida que se emiten valores de un observable, y al mismo tiempo generar nuevos observables a partir de cada valor emitido.</p><p>En este ejemplo sumamos de forma acomulativa los números del obersevable.</p>"
    },
    "pairwise": {
      "title": "Operador pairwise",
      "description": "<p>El operador <b>pairwise</b> de RxJS es un operador simple que agrupa los valores consecutivos emitidos por un observable en <b>pares</b>. Cada vez que el observable emite un nuevo valor, este operador toma el valor <b>anterior y el actual</b> y los combina en un array de dos elementos.</p><p>En este ejemplo podemos comprobar como se van concatenando en un array los dos últimos valores emitidos.</p>"
    },
    "partition": {
      "title": "Operador partition",
      "description": "<p>El operador <b>partition</b> de RxJS es una forma sencilla de dividir un flujo de datos (observable) en dos partes, según una condición. Básicamente, separa los valores emitidos en dos observables diferentes:</p><p>- <b>Un observable</b> para los valores que cumplen con la condición.</p><p>- <b>Otro observable</b> para los valores que no la cumplen.</p><p>En este ejemplo agrupamos los animales en dos grupos, los que son gatos y los que no lo son.</p>"
    },
    "pluck": {
      "title": "Operador pluck",
      "description": "<p>El operador <b>pluck</b> de RxJS es una forma sencilla de extraer un valor específico de un objeto emitido por un observable. Básicamente, es como acceder a una propiedad directamente usando su <b>nombre</b>, pero en el contexto de un flujo de datos.</p><p>En este ejemplo vamos a mostrar por consola los nombres de los animales de nuestro observable.</p>"
    },
    "scan": {
      "title": "Operador scan",
      "description": "<p>El operador <b>scan</b> de RxJS es muy similar a la función <b>reduce de los arreglos</b>, pero se aplica a flujos de datos (streams). Básicamente, acumula un valor a lo largo del tiempo, a medida que van llegando nuevos valores al flujo.</p><p>En este ejemplo sumamos de forma acumulativa los valores del observable.</p>"
    },
    "switchMap": {
      "title": "Operador switchMap",
      "description": "<p>El operador <b>switchMap</b> en RxJS se utiliza para cambiar de un observable a uno nuevo cada vez que el observable original emite un nuevo valor. Cuando esto ocurre, switchMap <b>cancela (o 'se desuscribe de')</b> el observable anterior y solo escucha al más reciente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic en el botón, podemos ver en la consola cómo se cancela el observable anterior.</p>"
    },
    "window": {
      "title": "Operador window",
      "description": "<p>El operador <b>window</b> de RxJS divide un flujo de datos (observable) en <b>sub-observables</b>, llamados <b>'ventanas'</b>. Cada ventana agrupa los elementos emitidos por el flujo original según un criterio definido, y se cierra cuando ocurre un evento determinado.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres</p>"
    },
    "windowCount": {
      "title": "Operador windowCount",
      "description": "<p>El operador <b>windowCount</b> de RxJS divide un flujo de datos (observable) en sub-observables (ventanas) basados en un <b>número fijo</b> de emisiones. Es decir, cada 'ventana' agrupa una cantidad específica de valores emitidos.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres comenzando cada 2 valores.</p>"
    },
    "windowTime": {
      "title": "Operador windowTime",
      "description": "<p>El operador <b>windowTime</b> de RxJS divide un flujo de datos (observable) en <b>'ventanas' de tiempo fijo</b>. Cada ventana es un sub-observable que agrupa los valores emitidos durante un intervalo de tiempo determinado.</p><p>En este ejemplo agrupamos los valores emitidos por el intervalo en ventanas de 3 segundos.</p>"
    },
    "windowToogle": {
      "title": "Operador windowToogle",
      "description": "<p>El operador <b>windowToggle</b> de RxJS divide un flujo de datos (observable) en ventanas que se abren y cierran según dos observables:</p><p><b>- Abridor (openings)</b>: Un observable que indica cuándo abrir una nueva ventana.</p><p>- <b>Cierre (closings)</b>: Una función que genera un observable para decidir cuándo cerrar esa ventana.</p><p>En este ejemplo emitimos los valores del intervalo abriendo una nueva ventana cada 5 segundos y cerrándola cada 3 segundos.</p>"
    },
    "windowWhen": {
      "title": "Operador windowWhen",
      "description": "<p>El operador <b>windowWhen</b> de RxJS divide un flujo de datos (observable) en ventanas que se <b>cierran y abren</b> según un criterio personalizado. Tú decides cuándo una ventana debe cerrarse y una nueva debe abrirse usando una función que genera observables.</p><p>En este ejemplo emitimos valores de un intervalo que se abre y cierra cada 3 segundos.</p>"
    }
  }
}
