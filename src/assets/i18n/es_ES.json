{
  "english": "Inglés",
  "spanish": "Español",
  "combination": {
    "title": "Operadores de combinación",
    "description": "<b>Los operadores de combinación en RxJS</b> permiten trabajar con múltiples observables para <b>combinarlos</b> y <b>crear nuevos</b> flujos de datos de manera flexible. Cada operador tiene un propósito específico dependiendo de cómo deseas combinar los valores de los observables.",
    "shortDescription": "Los operadores de combinación son herramientas clave para gestionar flujos de datos en tiempo real o flujos asincrónicos.",
    "combineLatest": {
      "title": "Operador combineLatest",
      "description": "<p>El operador <b>combineLatest</b> en RxJS es una forma de combinar múltiples observables en uno solo, emitiendo el <b>último valor</b> de cada uno de ellos con la <b>secuencia de valores</b> del último observable.</p>"
    },
    "concat": {
      "title": "Operador concat",
      "description": "<p>El operador <b>concat</b> en RxJS combina varios observables de manera secuencial, emitiendo los valores de <b>uno hasta que se complete</b>, y luego pasa al <b>siguiente</b>.</p>"
    },
    "concatAll": {
      "title": "Operador concatAll",
      "description": "<p>El operador <b>concatAll</b> en RxJS se utiliza para <b>'aplanar'</b> un flujo de observables de manera secuencial. Esto significa que si tienes un observable que emite otros observables, concatAll toma esos observables y los emite <b>uno por uno</b>, en el orden en que fueron emitidos, esperando a que cada uno termine antes de pasar al siguiente.</p>"
    },
    "exhaust": {
      "title": "Operador exhaust",
      "description": "<p>El operador <b>exhaust</b> en RxJS se utiliza para manejar flujos de observables de manera que, cuando un observable fuente emite un nuevo observable, el operador <b>solo escuchará al primer</b> observable y se ignorarán los nuevos observables emitidos hasta que el <b>primero termine</b>. En otras palabras, si el observable fuente sigue emitiendo observables, pero ya está 'trabajando' con uno, esos nuevos observables no serán escuchados hasta que el anterior termine.</p><p>En este ejmplo podemos comprobar como el delay del segundo observable impide que se ejecute el tercer observable.</p>"
    },
    "forkJoin": {
      "title": "Operador forkJoin",
      "description": "<p>El operador <b>forkJoin</b> en RxJS se utiliza para esperar a que todos los observables que se le pasen como argumentos <b>terminen</b> y, cuando todos hayan emitido su último valor, emite un solo <b>array con los últimos valores</b> de cada uno de esos observables.</p>"
    },
    "merge": {
      "title": "Operador merge",
      "description": "<p>El operador <b>merge</b> en RxJS se utiliza para combinar múltiples observables y emitir sus valores de manera <b>intercalada</b> (sin esperar a que uno termine antes de escuchar el siguiente). Los valores se emiten en el <b>mismo orden</b> en que los observables los producen, y todos los observables se suscriben y se ejecutan <b>simultáneamente</b>.</p>"
    },
    "mergeAll": {
      "title": "Operador mergeAll",
      "description": "<p>El operador <b>mergeAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de manera <b>diferente</b> a otros operadores como <b>concatAll</b>. Con mergeAll, cuando un observable emite otros observables, <b>todos</b> los observables se suscriben y se ejecutan de manera <b>simultánea</b>.</p>"
    },
    "race": {
      "title": "Operador race",
      "description": "<p>El operador <b>race</b> en RxJS se utiliza para <b>competir</b> entre varios observables y emitir los valores del <b>primer observable que emita algo</b>. Es decir, de todos los observables que se le pasen, el operador se suscribe solo al que primero emita un valor, y <b>descarta</b> los demás observables.</p>"
    },
    "startWith": {
      "title": "Operador startWith",
      "description": "<p>El operador <b>startWith</b> en RxJS se utiliza para emitir un <b>valor inicial antes</b> de que cualquier otro valor sea emitido por el observable. Es decir, puedes especificar un valor que se emitirá al principio, antes de que el observable comience a emitir sus propios valores.</p>"
    },
    "switchAll": {
      "title": "Operador switchAll",
      "description": "<p>El operador <b>switchAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de una manera especial: cuando un observable emite un <b>nuevo observable</b>, switchAll <b>deja de escuchar</b> al observable anterior y comienza a escuchar al nuevo observable. Es decir, siempre se suscribe solo al <b>último observable(s) emitido(s)</b> y cancela la suscripción a los anteriores.</p>"
    },
    "withLatestFrom": {
      "title": "Operador withLatestFrom",
      "description": "<p>El operador <b>withLatestFrom</b> en RxJS se utiliza para combinar el valor <b>más reciente</b> de un observable con los valores de otro observable, <b>sin suscribirse al segundo observable</b>. Esto significa que cuando el primer observable emite un valor, withLatestFrom toma el valor más reciente del segundo observable y lo combina con el valor emitido por el primer observable.</p>"
    }
  },

  "conditional": {
    "title": "Operadores condicionales",
    "description": "<b>Los operadores condicionales en RxJS</b> se utilizan para manejar flujos de datos de manera <b>condicional</b>, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "shortDescription": "Los operadores condicionales en RxJS se utilizan para manejar flujos de datos de manera condicional, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "defaultIfEmpty": {
      "title": "Operador defaultIfEmpty",
      "description": "<p>El operador <b>defaultIfEmpty</b> en RxJS se utiliza para proporcionar un <b>valor por defecto</b> cuando un observable <b>no emite ningún valor</b>. Es decir, si el observable está vacío (no emite nada), defaultIfEmpty emite el valor que especifiques como predeterminado.</p>"
    },
    "every": {
      "title": "Operador every",
      "description": "<p>El operador <b>every</b> en RxJS se utiliza para comprobar si todos los valores emitidos por un observable <b>cumplen con una condición específica</b>. Devuelve un observable que <b>emite true</b> si todos los valores emitidos cumplen la condición, y <b>false</b> si al menos uno de los valores no la cumple.</p>"
    },
    "find": {
      "title": "Operador find",
      "description": "<p>El operador <b>find</b> en RxJS se utiliza para buscar el <b>primer valor</b> que cumpla con una condición específica en un observable. A diferencia de otros operadores como <b>filter</b>, que emite <b>todos</b> los valores que cumplen la condición, find devuelve solo el primer valor que cumple la condición o undefined si ningún valor lo cumple.</p>"
    },
    "findIndex": {
      "title": "Operador findIndex",
      "description": "<p>El operador <b>findIndex</b> en RxJS es muy parecido al operador find, pero en lugar de devolver el primer valor que cumple con una condición, <b>devuelve el índice</b> de ese valor. Si ningún valor cumple la condición, devuelve <b>-1</b>.</p>"
    },
    "isEmpty": {
      "title": "Operador isEmpty",
      "description": "<p>El operador <b>isEmpty</b> en RxJS se utiliza para verificar si un observable <b>no emite ningún valor</b>. Devuelve un observable que emite:</p><p>- <b>true</b> si el observable no emite ningún valor.</p><p>- <b>false</b> si el observable emite al menos un valor.<p>"
    },
    "sequenceEqual": {
      "title": "Operador sequenceEqual",
      "description": "<p>El operador <b>sequenceEqual</b> en RxJS se utiliza para comprobar si <b>dos observables</b> emiten exactamente <b>la misma secuencia de valores, en el mismo orden</b>.</p>"
    }
  },
  "creation": {
    "title": "Operadores de creación",
    "description": "<b>En RxJS, los operadores de creación</b> son funciones que <b>generan observables</b> desde cero o a partir de otros valores o estructuras. Estos operadores permiten crear flujos de datos que luego pueden ser procesados.",
    "shortDescription": "En RxJS, los operadores de creación son funciones que generan observables desde cero o a partir de otros valores o estructuras.",
    "ajax": {
      "title": "Operador ajax",
      "description": "<p>El operador <b>ajax</b> de RxJS es una utilidad para <b>realizar solicitudes HTTP</b> (como GET, POST, PUT, DELETE) de manera sencilla y manejar las respuestas en forma de observables. Es ideal para trabajar con datos que provienen de APIs.</p>"
    },
    "defer": {
      "title": "Operador defer",
      "description": "<p>El operador <b>defer</b> en RxJS es como una <b>'fábrica de observables'</b>. Su propósito principal es crear un <b>nuevo observable</b> cuando alguien se <b>suscribe</b>, en lugar de hacerlo inmediatamente. Esto permite que el observable se genere bajo demanda, asegurándose de que siempre se ejecute con la lógica o datos más actualizados.</p>"
    },
    "from": {
      "title": "Operador from",
      "description": "<p>El operador <b>from</b> es como un puente entre estructuras comunes de JavaScript y el mundo reactivo de RxJS. Convierte cosas como <b>arrays y promesas en observables</b> que puedes usar en tus flujos reactivos.</p>"
    },
    "fromEvent": {
      "title": "Operador fromEvent",
      "description": "<p>El operador <b>fromEvent</b> de RxJS convierte un <b>evento en un observable</b>. Esto significa que puedes escuchar eventos, como clics del ratón, movimientos del cursor, teclas presionadas, y trabajar con ellos como flujos de datos.</p>"
    },
    "generate": {
      "title": "Operador generate",
      "description": "<p>El operador <b>generate</b> de RxJS es una forma avanzada de <b>crear observables</b> que emiten una secuencia de valores basada en una <b>función generadora</b>. Permite generar un flujo de datos personalizado mediante la especificación de condiciones de inicio, continuación y actualización de los valores que se emiten.</p>"
    },
    "iif": {
      "title": "Operador iif",
      "description": "<p>El operador <b>iif</b> en RxJS es una forma de crear un observable condicional. En otras palabras, iif te permite <b>decidir</b> qué observable emitir en función de una condición.</p>"
    },
    "interval": {
      "title": "Operador interval",
      "description": "<p>El operador <b>interval</b> de RxJS <b>crea</b> un observable que emite <b>valores numéricos</b> de manera continua, comenzando desde 0, y luego incrementando cada vez después de un intervalo de tiempo específico.</p>"
    },
    "of": {
      "title": "Operador of",
      "description": "<p>El operador <b>of</b> de RxJS crea un observable a partir de un conjunto de valores que le pases. Estos valores pueden ser <b>cualquier tipo de dato</b>, como números, cadenas, objetos, etc.</p>"
    },
    "range": {
      "title": "Operador range",
      "description": "<p>El operador <b>range</b> de RxJS crea un observable que emite una secuencia de números dentro de un rango especificado, comenzando desde un valor <b>inicial</b> y hasta un valor <b>final</b>.</p>"
    },
    "throwError": {
      "title": "Operador throwError",
      "description": "<p>El operador <b>throwError</b> de RxJS se utiliza para <b>emitir un error</b> en un observable de manera manual. Esto es útil cuando deseas que un flujo de datos se detenga debido a una condición específica y que se maneje un error.</p>"
    },
    "timer": {
      "title": "Operador timer",
      "description": "<p>El operador <b>timer</b> de RxJS crea un observable que emite un valor <b>después de un cierto período de tiempo</b> (en milisegundos) y luego puede seguir emitiendo valores a intervalos regulares si se le indica.</p>"
    }
  },
  "error": {
    "title": "Operadores de error",
    "description": "Los <b>operadores de gestión de error en RxJS</b> se utilizan para <b>manejar, recuperar o reaccionar ante errores</b> que pueden ocurrir en el flujo de datos de un Observable. Estos operadores permiten que tu aplicación no se detenga cuando ocurre un error, y te dan control sobre cómo manejarlo.",
    "shortDescription": "Los operadores de gestión de error en RxJS se utilizan para manejar, recuperar o reaccionar ante errores que pueden ocurrir en el flujo de datos de un Observable.",
    "catchError": {
      "title": "Operador catchError",
      "description": "<p>El operador <b>catchError</b> en RxJS se utiliza para <b>capturar un error</b> que ocurre en un Observable y permitir <b>manejarlo de una manera controlada</b>, sin que el flujo de datos se detenga.</p><p>Cuando un Observable emite un error, catchError te da la oportunidad de recuperarte de ese error. Puedes devolver un nuevo Observable que se emitirá en lugar del error, o simplemente realizar una acción cuando el error ocurra.</p>"
    },
    "retry": {
      "title": "Operador retry",
      "description": "<p>El operador <b>retry</b> en RxJS se utiliza para <b>volver a intentar ejecutar</b> un Observable en caso de que ocurra un error. Este operador te permite reintentar el flujo de datos automáticamente un <b>número específico de veces</b> antes de que finalmente falle.</p><p>En este ejemplo podremos comprobar en la consola del navegador como se reintenta llamar 1 vez a la url después del error.</p>"
    }
  },

  "filtering": {
    "title": "Operadores de filtración",
    "description": "En RxJS, <b>los operadores de filtración</b> se utilizan para <b>filtrar</b> los elementos emitidos por un observable, dejando pasar únicamente aquellos que cumplen con una condición específica. Estos operadores son útiles para trabajar con flujos de datos, asegurando que solo procesemos los valores relevantes.",
    "shortDescription": "En RxJS, los operadores de filtración se utilizan para filtrar los elementos emitidos por un observable, dejando pasar únicamente aquellos que cumplen con una condición específica.",
    "audit": {
      "title": "Operador audit",
      "description": "<p>El operador <b>audit</b> en RxJS se utiliza para <b>controlar la emisión</b> de valores de un observable, basándose en otro observable que actúa como una <b>'ventana de tiempo'</b>.</p>"
    },
    "auditTime": {
      "title": "Operador auditTime",
      "description": "<p>El operador <b>auditTime</b> en RxJS es una forma sencilla de controlar la frecuencia con la que se emiten valores de un observable. Funciona de manera <b>similar a audit</b>, pero en lugar de depender de un observable externo, usa un <b>período de tiempo fijo</b> que tú defines.</p>"
    },
    "debounce": {
      "title": "Operador debounce",
      "description": "<p>El operador <b>debounce</b> en RxJS es útil para controlar <b>cuántos valores</b> de un observable se procesan, especialmente cuando los valores llegan rápidamente (como pulsaciones de teclas o clics). Este operador <b>espera un período de tiempo</b> tras recibir un valor, y solo emite ese valor si no se han recibido nuevos valores durante ese tiempo.</p><p>En este ejemplo mostraremos por consola la última tecla presionada.</p>"
    },
    "debounceTime": {
      "title": "Operador debounceTime",
      "description": "<p>El operador <b>debounceTime</b> en RxJS es muy similar a debounce, pero en lugar de usar un observable para definir el tiempo de espera, simplemente se utiliza <b>un período de tiempo fijo</b>.</p>"
    },
    "distinct": {
      "title": "Operador distinct",
      "description": "<p>El operador <b>distinct</b> en RxJS se utiliza para <b>filtrar valores duplicados</b> que un observable pueda emitir. Emite solo los <b>valores únicos</b> (es decir, los que no se repiten) y descarta los valores que ya han sido emitidos previamente.</p>"
    },
    "distinctUntilChanged": {
      "title": "Operador distinctUntilChanged",
      "description": "<p>El operador <b>distinctUntilChanged</b> en RxJS se utiliza para filtrar valores <b>consecutivos repetidos</b> en un flujo de datos. Emite un valor solo si es diferente al último valor emitido.</p>"
    },
    "distinctUntilKeyChanged": {
      "title": "Operador distinctUntilKeyChanged",
      "description": "<p>El operador <b>distinctUntilKeyChanged</b> en RxJS es muy similar a distinctUntilChanged, pero se utiliza cuando los valores que emite el observable son <b>objetos</b> o contienen propiedades, y deseas filtrar los valores que no han cambiado en <b>una propiedad específica</b>.</p>"
    },
    "elementAt": {
      "title": "Operador elementAt",
      "description": "<p>El operador <b>elementAt</b> en RxJS se utiliza para obtener un <b>valor específico en una posición determinada</b> de un flujo de datos emitido por un observable.</p>"
    },
    "filter": {
      "title": "Operador filter",
      "description": "<p>El operador <b>filter</b> en RxJS se utiliza para filtrar los valores que un observable emite, permitiendo que solo pasen los valores que <b>cumplan con una condición específica</b>.</p><p>En este ejemplo filtramos por los usuarios que tengan más de 3 años y tengan nombres diferentes.</p>"
    },
    "first": {
      "title": "Operador first",
      "description": "<p>El operador <b>first</b> en RxJS se utiliza para emitir solo el <b>primer valor</b> de un observable que <b>cumpla con una condición específica</b>, o simplemente el <b>primer</b> valor si no se define <b>ninguna</b> condición.  Si el observable no emite ningún valor, puede lanzar un error o emitir un valor predeterminado si lo especificas.</p>"
    },
    "ignoreElements": {
      "title": "Operador ignoreElements",
      "description": "<p>El operador <b>ignoreElements</b> en RxJS se utiliza para ignorar <b>todos</b> los valores emitidos por un observable. Este operador <b>no emite nada</b>, pero sí pasa los errores o la <b>señal</b> de que el observable se <b>completó</b>.</p>"
    },
    "last": {
      "title": "Operador last",
      "description": "<p>El operador <b>last</b> en RxJS se utiliza para emitir solo el <b>último valor</b> de un observable que <b>cumpla con una condición específica</b>. Si el observable no emite ningún valor, puede lanzar un error o emitir un valor predeterminado si lo especificas.</p><p>En este ejemplo forzamos que no encuentre ningún valor, para ver el mensaje de error por defecto.<p>"
    },
    "sample": {
      "title": "Operador sample",
      "description": "<p>El operador <b>sample</b> en RxJS se utiliza para <b>tomar el último valor</b> emitido por un observable en <b>momentos específicos</b> definidos por otro observable que actúa como una 'fuente de tiempo'.<p><p>En este ejemplo solo cogemos del intervalo el valor último que emite cada 5 segundos.</p>"
    },
    "sampleTime": {
      "title": "Operador sampleTime",
      "description": "<p>El operador <b>sampleTime</b> en RxJS se utiliza para <b>tomar el último valor</b> emitido por un observable en <b>intervalos de tiempo fijos</b>. Cada vez que pasa el tiempo especificado, el operador emite el último valor que se ha producido hasta ese momento.</p>"
    },
    "single": {
      "title": "Operador single",
      "description": "<p>El operador <b>single</b> en RxJS se utiliza para <b>asegurarse</b> de que un observable emite <b>solo un valor</b>, y ese valor <b>debe cumplir con una condición específica</b> (si se define). Si el observable emite más de un valor o no emite ninguno, se <b>lanzará un error</b>.</p>"
    },
    "skip": {
      "title": "Operador skip",
      "description": "<p>El operador <b>skip</b> en RxJS es una herramienta que se utiliza para <b>ignorar un cierto número de valores iniciales</b> emitidos por un observable. Después de 'saltar' estos valores, comienza a pasar los siguientes valores que se emitan.</p>"
    },
    "skipLast": {
      "title": "Operador skipLast",
      "description": "<p>El operador <b>skipLast</b> en RxJS es muy parecido a skip, pero en lugar de ignorar valores al principio, <b>ignora los últimos valores emitidos</b> por un observable. Esto significa que deja pasar todos los valores, excepto los últimos <b>n</b>.</p>"
    },
    "skipUntil": {
      "title": "Operador skipUntil",
      "description": "<p>El operador <b>skipUntil</b> en RxJS se utiliza para <b>ignorar valores emitidos por un observable</b> hasta que <b>otro observable emita un valor</b>. En ese momento, empieza a dejar pasar los valores del observable original.</p>"
    },
    "skipWhile": {
      "title": "Operador skipWhile",
      "description": "<p>El operador <b>skipWhile</b> en RxJS se utiliza para <b>ignorar valores emitidos por un observable mientras se cumpla una condición</b>. Tan pronto como la condición deja de cumplirse, comienza a pasar los valores emitidos por el observable.</p>"
    },
    "take": {
      "title": "Operador take",
      "description": "<p>El operador <b>take</b> en RxJS se utiliza para <b>limitar la cantidad de valores</b> que un observable puede emitir. Una vez que el observable ha emitido la cantidad <b>especificada</b> de valores, se completa automáticamente.</p>"
    },
    "takeLast": {
      "title": "Operador takeLast",
      "description": "<p>El operador <b>takeLast</b> en RxJS se utiliza para tomar los <b>últimos n valores emitidos</b> por un observable, después de que el observable se haya completado.</p>"
    },
    "takeUntil": {
      "title": "Operador takeUntil",
      "description": "<p>El operador <b>takeUntil</b> en RxJS se utiliza para tomar valores emitidos por un observable <b>hasta que otro observable emita un valor</b>. Cuando ese <b>otro observable emite</b>, el flujo del <b>observable original se completa</b>, es decir, deja de emitir más valores.</p>"
    },
    "takeWhile": {
      "title": "Operador takeWhile",
      "description": "<p>El operador <b>takeWhile</b> en RxJS se utiliza para tomar valores emitidos por un observable <b>mientras se cumpla una condición</b>. En el momento en que la condición <b>deje de cumplirse</b>, el <b>observable se completa</b> y deja de emitir más valores.</p>"
    },
    "throttle": {
      "title": "Operador throttle",
      "description": "<p>El operador <b>throttle</b> en RxJS se utiliza para <b>limitar la frecuencia de emisiones</b> de un observable, asegurando que solo se emita <b>un valor en un intervalo de tiempo determinado</b>, y los valores que lleguen antes de que pase ese intervalo se ignoren.</p><p>En este ejemplo, estamos utilizando el operador <b>throttle</b> para ignorar las emisiones que ocurren dentro de un intervalo de 5 segundos. Esto provoca que solo se emitan los valores que ocurren al final de cada intervalo, lo que resulta en un incremento de 6 entre los valores emitidos.</p>"
    },
    "throttleTime": {
      "title": "Operador throttleTime",
      "description": "<p>El operador <b>throttleTime</b> en RxJS se utiliza para <b>limitar la frecuencia de emisiones</b> de un observable, de forma <b>similar a throttle</b>, pero de una manera más <b>sencilla</b>. Con throttleTime, <b>puedes especificar un intervalo de tiempo</b> durante el cual se permitirá solo una emisión, ignorando todas las emisiones intermedias.</p>"
    }
  },
  "mathematical": {
    "title": "Operadores matemáticos",
    "description": "<b>Los operadores matemáticos en RxJS</b> se utilizan para realizar cálculos y <b>transformaciones matemáticas</b> en los valores emitidos por un observable. Estos operadores permiten sumar, promediar, o encontrar valores mínimos o máximos dentro de un flujo de datos.",
    "shortDescription": "Los operadores matemáticos en RxJS se utilizan para realizar cálculos y transformaciones matemáticas en los valores emitidos por un observable.",
    "count": {
      "title": "Operador count",
      "description": "<p>El operador <b>count</b> en RxJS se utiliza para contar la <b>cantidad de valores</b> emitidos por un observable <b>que cumplen con una condición específica</b>. Si no se proporciona una condición, cuenta todos los valores emitidos.</p>"
    },
    "max": {
      "title": "Operador max",
      "description": "<p>El operador <b>max</b> en RxJS se utiliza para encontrar el <b>valor máximo</b> emitido por un observable. Este operador compara todos los valores emitidos y devuelve el que sea el más alto.</p>"
    },
    "min": {
      "title": "Operador min",
      "description": "<p>El operador <b>min</b> en RxJS se utiliza para encontrar el <b>valor mínimo</b> emitido por un observable. Este operador compara todos los valores emitidos y devuelve el que sea el más bajo.</p>"
    },
    "reduce": {
      "title": "Operador reduce",
      "description": "<p>El operador <b>reduce</b> en RxJS se utiliza para <b>acumular los valores emitidos</b> por un observable, similar a cómo funciona reduce en los arrays de JavaScript. Toma todos los valores emitidos y los va combinando en un solo valor final.</p>"
    }
  },
  "multicasting": {
    "title": "Operadores de multidifusión",
    "description": "Los <b>operadores de multidifusión en RxJS</b> se utilizan para compartir <b>un solo flujo de valores</b> entre múltiples suscriptores, de modo que los valores emitidos por el observable no se repitan para cada suscriptor. Esto <b>optimiza el rendimiento</b> al evitar que los valores se emitan varias veces para cada suscriptor.",
    "shortDescription": "Los operadores de multidifusión en RxJS se utilizan para compartir un solo flujo de valores entre múltiples suscriptores, de modo que los valores emitidos por el observable no se repitan para cada suscriptor.",
    "connect": {
      "title": "Operador connect",
      "description": "<p>El operador <b>connect</b> en RxJS se utiliza para <b>ctivar</b> un observable que está configurado para ser compartido a través de un subject (usualmente con publish() o multicast()). Este operador permite que el observable comience a emitir valores solo después de que se llame a <b>connect()</b>, es decir, controla cuando el observable comienza a emitir valores.</p>"
    },
    "share": {
      "title": "Operador share",
      "description": "<p>El operador <b>share</b> en RxJS es una forma de multidifusión que permite que un <b>único flujo de datos</b> emitido por un observable sea compartido entre múltiples suscriptores, sin que cada suscriptor <b>reciba sus propias emisiones</b>. Esto evita que el observable sea ejecutado <b>más de una vez</b>, optimizando el rendimiento.</p>"
    },
    "shareReplay": {
      "title": "Operador shareReplay",
      "description": "<p>El operador <b>shareReplay</b> en RxJS es similar al operador share, pero con una diferencia clave: <b>mantiene en caché los últimos valores emitidos por el observable y los reproduce (replay) a nuevos suscriptores</b>. Es útil cuando quieres que los nuevos suscriptores reciban los últimos valores emitidos sin volver a ejecutar todo el flujo de datos.</p>"
    }
  },

  "transformation": {
    "title": "Operadores de transformación",
    "description": "<b>Los operadores de transformación de RxJS</b> son herramientas que te permiten cambiar (o 'transformar') los datos que fluyen a través de un flujo observable. Imagina que tienes un flujo de valores, como números u objetos, y quieres modificar, filtrar o reestructurar estos valores antes de que lleguen al observador final.",
    "shortDescription": "Los operadores de transformación de RxJS son herramientas para modificar los datos que fluyen por un observable.",
    "buffer": {
      "title": "Operador buffer",
      "description": "<p>El operador <b>buffer</b> de RxJS recopila las emisiones de un observable fuente en un array y las entrega juntas cuando otro observable, conocido como <b>disparador</b> (trigger), emite un valor. Es útil para agrupar valores durante intervalos de tiempo o en respuesta a eventos.<p><p>En este ejemplo contabilizamos los clicks que se hace en un botón cada 3 segundos.</p> "
    },
    "bufferCount": {
      "title": "Operador bufferCount",
      "description": "<p>El operador <b>bufferCount</b> de RxJS se utiliza para agrupar emisiones de un observable en 'buffers' o lotes de tamaño <b>fijo</b> y emitirlos como un array.</p><p>En este ejemplo emitiremos el array al hacer 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operador bufferTime",
      "description": "<p>El operador <b>bufferTime</b> de RxJS agrupa las emisiones de un observable durante un período de <b>tiempo fijo</b> y las emite juntas como un array.</p><p>En este ejemplo, mostramos el array que se genera con la emisión del intervalo cada 3 segundos.</p>"
    },
    "bufferToogle": {
      "title": "Operador bufferToogle",
      "description": "<p>El operador <b>bufferToggle</b> de RxJS te permite recolectar valores emitidos por un observable en buffers (arreglos) y emitir esos buffers en función de señales provenientes de otros observables. Funciona abriendo y cerrando buffers basados en eventos disparados por observables de <b>apertura y cierre</b>.</p><p>En este ejemplo capturaremos los valores emitidos en un intervalo de 1 segundo desde que presionemos 'Start' hasta que presionemos 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operador bufferWhen",
      "description": "<p>El operador <b>bufferWhen</b> de RxJS permite recolectar valores emitidos por un observable fuente en 'buffers' (arreglos) y emitir esos buffers cuando <b>se cumple una condición</b>. La condición para cerrar cada buffer se define a través de una función que devuelve un observable. Cuando este observable emite un valor, el buffer se cierra y se inicia uno nuevo.</p><p>En este ejemplo capturaremos los valores emitidos por un intervalo de 1 segundo, cada vez que hagamos click en el botón.</p>"
    },
    "concatMap": {
      "title": "Operador concatMap",
      "description": "<p>El operador <b>concatMap</b> en RxJS se utiliza para encadenar observables uno tras otro, asegurándose de que se ejecuten en secuencia. Cuando concatMap recibe un valor, lo mapea a un nuevo observable (como una solicitud de red o un temporizador) y espera a que este se complete antes de pasar al siguiente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic, podemos ver en la consola cómo los observables se concatenan de manera ordenada, respetando su secuencia.</p>"
    },
    "exhaustMap": {
      "title": "Operador exhaustMap",
      "description": "<p>El operador <b>exhaustMap</b> en RxJS sirve para manejar flujos de datos <b>asincrónicos</b> asegurándote de que solo procese <b>una operación a la vez</b> y que ignore cualquier nueva acción mientras la operación actual sigue en curso.</p><p>En este ejemplo cargamos una lista de usuarios a través del clic de un botón. Podremos comprobar como no se carga la lista hasta que la llamada previa haya finalizado.</p>"
    },
    "expand": {
      "title": "Operador expand",
      "description": "<p>El operador <b>expand</b> en RxJS se utiliza para generar un flujo de valores de manera <b>recursiva</b>, es decir, permite que cada valor emitido pueda <b>generar nuevos valores</b> basados en una lógica definida.</p><p>En este ejemplo, a cada valor emitido le sumamos 10 hasta repetir 5 veces la operación.</p>"
    },
    "groupBy": {
      "title": "Operador groupBy",
      "description": "<p>El operador <b>groupBy</b> de RxJS se utiliza para agrupar elementos emitidos por un observable <b>según una clave</b> que tú defines. Piensa en él como una forma de separar un flujo de datos en diferentes 'cajones' según alguna característica.</p><p>En este ejemplo agrupamos las especies en diferentes arreglos, a través de un mergeMap y un toArray.</p>"
    },
    "map": {
      "title": "Operador map",
      "description": "<p>El operador <b>map</b> en RxJS aplica una función a cada valor emitido por un observable y devuelve un observable que emite los valores transformados.</p><p>En este ejemplo, transformamos el nombre del usuario utilizando el operador map y usamos el método map del arreglo para actualizar el nombre de cada elemento dentro de él.</p>"
    },
    "mapTo": {
      "title": "Operador mapTo",
      "description": "<p>El operador <b>mapTo</b> en RxJS reemplaza cada valor emitido por un observable con un valor específico que proporcionas.</p><p>En este ejemplo, con el operador mapTo, reemplazamos todos los valores del observable con el valor <b>fresa</b>.</p>"
    },
    "mergeMap": {
      "title": "Operador mergeMap",
      "description": "<p>El operador <b>mergeMap</b> en RxJS se utiliza para transformar los valores emitidos por un observable en otros observables y luego <b>'aplana'</b> o combina todas esas emisiones en un único flujo de datos. Esto es útil cuando deseas realizar múltiples operaciones asíncronas en secuencia y combinar sus resultados.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operador mergeMapTo",
      "description": "<p>El operador <b>mergeMapTo</b> en RxJS se utiliza para reemplazar cada valor emitido por un observable con un observable diferente que especifiques, y luego 'aplana' todos los resultados en un único flujo de salida.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2. <b>A diferencia de mergeMap</b>, no tomamos en cuenta la salida del primer observable, emitiendo el <b>mismo valor</b> para cada letra.</p>"
    },
    "mergeScan": {
      "title": "Operador mergeScan",
      "description": "<p>El operador <b>mergeScan</b> de RxJS es como una combinación de un <b>reduce</b> y un <b>mergeMap</b>, pero se aplica a un flujo de datos (un observable) en lugar de a una colección estática como un array. Se utiliza cuando quieres mantener un estado acumulativo a medida que se emiten valores de un observable, y al mismo tiempo generar nuevos observables a partir de cada valor emitido.</p><p>En este ejemplo sumamos de forma acomulativa los números del obersevable.</p>"
    },
    "pairwise": {
      "title": "Operador pairwise",
      "description": "<p>El operador <b>pairwise</b> de RxJS es un operador simple que agrupa los valores consecutivos emitidos por un observable en <b>pares</b>. Cada vez que el observable emite un nuevo valor, este operador toma el valor <b>anterior y el actual</b> y los combina en un array de dos elementos.</p><p>En este ejemplo podemos comprobar como se van concatenando en un array los dos últimos valores emitidos.</p>"
    },
    "partition": {
      "title": "Operador partition",
      "description": "<p>El operador <b>partition</b> de RxJS es una forma sencilla de dividir un flujo de datos (observable) en dos partes, según una condición. Básicamente, separa los valores emitidos en dos observables diferentes:</p><p>- <b>Un observable</b> para los valores que cumplen con la condición.</p><p>- <b>Otro observable</b> para los valores que no la cumplen.</p><p>En este ejemplo agrupamos los animales en dos grupos, los que son gatos y los que no lo son.</p>"
    },
    "pluck": {
      "title": "Operador pluck",
      "description": "<p>El operador <b>pluck</b> de RxJS es una forma sencilla de extraer un valor específico de un objeto emitido por un observable. Básicamente, es como acceder a una propiedad directamente usando su <b>nombre</b>, pero en el contexto de un flujo de datos.</p><p>En este ejemplo vamos a mostrar por consola los nombres de los animales de nuestro observable.</p>"
    },
    "scan": {
      "title": "Operador scan",
      "description": "<p>El operador <b>scan</b> de RxJS es muy similar a la función <b>reduce de los arreglos</b>, pero se aplica a flujos de datos (streams). Básicamente, acumula un valor a lo largo del tiempo, a medida que van llegando nuevos valores al flujo.</p><p>En este ejemplo sumamos de forma acumulativa los valores del observable.</p>"
    },
    "switchMap": {
      "title": "Operador switchMap",
      "description": "<p>El operador <b>switchMap</b> en RxJS se utiliza para cambiar de un observable a uno nuevo cada vez que el observable original emite un nuevo valor. Cuando esto ocurre, switchMap <b>cancela (o 'se desuscribe de')</b> el observable anterior y solo escucha al más reciente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic en el botón, podemos ver en la consola cómo se cancela el observable anterior.</p>"
    },
    "window": {
      "title": "Operador window",
      "description": "<p>El operador <b>window</b> de RxJS divide un flujo de datos (observable) en <b>sub-observables</b>, llamados <b>'ventanas'</b>. Cada ventana agrupa los elementos emitidos por el flujo original según un criterio definido, y se cierra cuando ocurre un evento determinado.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres</p>"
    },
    "windowCount": {
      "title": "Operador windowCount",
      "description": "<p>El operador <b>windowCount</b> de RxJS divide un flujo de datos (observable) en sub-observables (ventanas) basados en un <b>número fijo</b> de emisiones. Es decir, cada 'ventana' agrupa una cantidad específica de valores emitidos.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres comenzando cada 2 valores.</p>"
    },
    "windowTime": {
      "title": "Operador windowTime",
      "description": "<p>El operador <b>windowTime</b> de RxJS divide un flujo de datos (observable) en <b>'ventanas' de tiempo fijo</b>. Cada ventana es un sub-observable que agrupa los valores emitidos durante un intervalo de tiempo determinado.</p><p>En este ejemplo agrupamos los valores emitidos por el intervalo en ventanas de 3 segundos.</p>"
    },
    "windowToogle": {
      "title": "Operador windowToogle",
      "description": "<p>El operador <b>windowToggle</b> de RxJS divide un flujo de datos (observable) en ventanas que se abren y cierran según dos observables:</p><p><b>- Abridor (openings)</b>: Un observable que indica cuándo abrir una nueva ventana.</p><p>- <b>Cierre (closings)</b>: Una función que genera un observable para decidir cuándo cerrar esa ventana.</p><p>En este ejemplo emitimos los valores del intervalo abriendo una nueva ventana cada 5 segundos y cerrándola cada 3 segundos.</p>"
    },
    "windowWhen": {
      "title": "Operador windowWhen",
      "description": "<p>El operador <b>windowWhen</b> de RxJS divide un flujo de datos (observable) en ventanas que se <b>cierran y abren</b> según un criterio personalizado. Tú decides cuándo una ventana debe cerrarse y una nueva debe abrirse usando una función que genera observables.</p><p>En este ejemplo emitimos valores de un intervalo que se abre y cierra cada 3 segundos.</p>"
    }
  },
  "utility": {
    "title": "Operadores de utilidad",
    "description": "<b>Los <b>operadores de utilidad en RxJS</b> son herramientas que <b>ayudan a controlar y manejar flujos de datos</b> (Observables) de manera más eficiente, <b>sin transformar</b> directamente los valores que pasan por ellos. Son como <b>'ayudantes'</b> para tareas comunes, como depuración, suscripción, o manipulación del flujo.",
    "shortDescription": "Los operadores de utilidad en RxJS son herramientas que ayudan a controlar y manejar flujos de datos (Observables) de manera más eficiente, sin transformar directamente los valores que pasan por ellos.",
    "delay": {
      "title": "Operador delay",
      "description": "<p>El operador <b>delay</b> de RxJS es como un <b>'reloj' que retrasa</b> las emisiones de valores de un Observable por un período de tiempo que <b>tú determines</b>.</p>"
    },
    "delayWhen": {
      "title": "Operador delayWhen",
      "description": "<p>El operador <b>delayWhen</b> de RxJS es como <b>delay</b>, pero <b>más flexible</b>. En lugar de retrasar un valor por un tiempo fijo, <b>permite retrasarlo usando otro Observable </b> para decidir cuándo se debe emitir.</p>"
    },
    "dematerialize": {
      "title": "Operador dematerialize",
      "description": "<p>El operador <b>dematerialize</b> en RxJS convierte las <b>'notificaciones'</b> de un Observable <b>(que están encapsuladas como objetos especiales)</b> <b>nuevamente en valores normales o eventos</b>.</p>"
    },
    "finalize": {
      "title": "Operador finalize",
      "description": "<p>El operador <b>finalize</b> en RxJS se usa para ejecutar una <b>acción cuando un Observable termina (ya sea completando o teniendo un error)</b>. Es como un 'limpiador' que asegura que algo ocurra al final del flujo de datos, sin importar si todo fue exitoso o hubo un error.</p>"
    },
    "materialize": {
      "title": "Operador materialize",
      "description": "<p>El operador <b>materialize</b> en RxJS convierte las emisiones de un Observable en <b>notificaciones</b>. Es decir, en lugar de emitir solo los valores, el Observable emite <b>objetos que representan los eventos de flujo como next, error o complete.</b></p>"
    },
    "repeat": {
      "title": "Operador repeat",
      "description": "<p>El operador <b>repeat</b> en RxJS se usa para <b>volver a emitir</b> un Observable después de que este haya completado, <b>repitiendo su flujo</b> el número de veces que le indiques.</p>"
    },
    "tap": {
      "title": "Operador tap",
      "description": "<p>El operador <b>tap</b> en RxJS es muy útil para <b>interceptar y observar</b> las emisiones de un Observable sin modificar sus valores. Es como un 'espía' que te permite realizar acciones secundarias (como hacer un registro en consola) en el flujo de datos, pero sin afectar los datos que pasan a través del Observable.</p>"
    },
    "timeInterval": {
      "title": "Operador timeInterval",
      "description": "<p>El operador <b>timeInterval</b> en RxJS se usa para <b>medir el tiempo transcurrido entre las emisiones</b> de un Observable. Es como un reloj que te dice cuánto tiempo ha pasado entre cada emisión de un valor.</p>"
    },
    "timeout": {
      "title": "Operador timeout",
      "description": "<p>El operador <b>timeout</b> en RxJS se utiliza para <b>establecer un límite de tiempo en un Observable</b>. Si el Observable <b>no emite un valor</b> dentro del tiempo especificado, se emite un <b>error o una acción predeterminada</b>.</p><p>En este ejemplo creamos un observable a través del <b>operador timer</b>, pero como el operador <b>timeout</b> tiene un intervalo de tiempo menor, forzaremos el error.</p>"
    },
    "timestamp": {
      "title": "Operador timestamp",
      "description": "<p>El operador <b>timestamp</b> en RxJS se utiliza para <b>añadir una marca de tiempo (timestamp) a cada valor emitido</b> por un Observable. Esta marca de tiempo indica el momento exacto (en milisegundos desde la época Unix) en que el valor fue emitido.</p>"
    },
    "toArray": {
      "title": "Operador toArray",
      "description": "<p>El operador <b>toArray</b> en RxJS se usa para <b>recoger todos los valores emitidos</b> por un Observable y <b>almacenarlos en un arreglo (array)</b>. Una vez que el Observable <b>ha completado su emisión</b> de valores, <b>toArray devuelve ese arreglo</b> con todos los valores emitidos.</p><p>En este ejemplo cogemos solo 10 valores emitidos por un intervalo y los agrupamos en un array.</p>"
    }
  },
  "subjects": {
    "title": "Subjects",
    "description": "<b>En RxJS, los Subjects son un concepto clave que combina dos roles: el de un observable (algo que emite valores) y el de un observer (algo que recibe valores). Esto significa que puedes usarlos tanto para recibir datos como para emitirlos a otros observadores. Permiten la multidifusión de valores a muchos Observadores. Mientras los <b>Observables simples son de monodifusión</b> (cada Observador suscrito es propietario de una ejecución independiente del Observable), los subjects son de <b>multidifusión</b>.",
    "shortDescription": "En RxJS, los Subjects son un concepto clave que combina dos roles: el de un observable (algo que emite valores) y el de un observer (algo que recibe valores).",
    "behaviorSubject": {
      "title": "BehaviorSubject",
      "description": "<p>El <b>BehaviorSubject</b> es un tipo especial de Subject en RxJS que siempre tiene un <b>valor inicial</b> y además <b>recuerda el último valor emitido</b>. Esto significa que cualquier nuevo suscriptor automáticamente recibe el valor más reciente, incluso si se suscribe después de que ese valor haya sido emitido.</p><p>Podemos acceder al contenido de este sin la necesidad de subscribirnos a través del método <b>getValue</b>.<p>En este ejemplo creamos un <b>BehaviorSubject</b> e inmediatamente se propaga su contenido a todas las subcripciones (valor inicial). También mostramos su contenido por consola a través del método <b>getValue</b> y luego modificamos la edad de este a través del método <b>next</b>, el cual <b>propaga el cambio</b> y vemos el <b>nuevo valor en la subscripción</b>.</p>"
    },
    "replaySubject": {
      "title": "ReplaySubject",
      "description": "<p>El <b>ReplaySubject</b> en RxJS es un tipo de Subject que <b>guarda un historial de valores emitidos</b> y, cuando un nuevo suscriptor se une, le reproduce todos los valores que se han emitido hasta ese momento. Puedes configurar cuántos valores anteriores deseas que el ReplaySubject recuerde.</p><p>En este ejemplo le damos a nuestro ReplaySubject los valores que emite un <b>intervalo</b> y a los 5 segundos nos suscribimos a este, donde podremos visualizar los <b>2 últimos almacenados</b>.</p>"
    },
    "subject": {
      "title": "Subject",
      "description": "<p>El <b>Subject</b> es un tipo especial de Subject en RxJS que no requiere de un <b>valor inicial</b> y además <b>recuerda el último valor emitido</b>. Esto significa que cualquier nuevo suscriptor automáticamente recibe el valor más reciente, incluso si se suscribe después de que ese valor haya sido emitido.</p><p>En este ejemplo a través de un evento clic y en función del contenido de la variable user, creamos el usuario o incrementamos su edad y a través de la función <b>next</b> propagamos el cambio.</p>"
    }
  }
}
