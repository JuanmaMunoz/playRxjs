{
  "english": "Inglés",
  "spanish": "Español",
  "combination": {
    "title": "Operadores de Combinación",
    "description": "<b>Los operadores de combinación en RxJS</b> permiten trabajar con múltiples observables para <b>combinarlos</b> y <b>crear nuevos</b> flujos de datos de manera flexible. Cada operador tiene un propósito específico dependiendo de cómo deseas combinar los valores de los observables.",
    "shortDescription": "Los operadores de combinación son herramientas clave para gestionar flujos de datos en tiempo real o flujos asincrónicos.",
    "combineLatest": {
      "title": "Operador combineLatest",
      "description": "<p>El operador <b>combineLatest</b> en RxJS es una forma de combinar múltiples observables en uno solo, emitiendo el <b>último valor</b> de cada uno de ellos con la <b>secuencia de valores</b> del último observable.</p>"
    },
    "concat": {
      "title": "Operador concat",
      "description": "<p>El operador <b>concat</b> en RxJS combina varios observables de manera secuencial, emitiendo los valores de <b>uno hasta que se complete</b>, y luego pasa al <b>siguiente</b>.</p>"
    },
    "concatAll": {
      "title": "Operador concatAll",
      "description": "<p>El operador <b>concatAll</b> en RxJS se utiliza para <b>'aplanar'</b> un flujo de observables de manera secuencial. Esto significa que si tienes un observable que emite otros observables, concatAll toma esos observables y los emite <b>uno por uno</b>, en el orden en que fueron emitidos, esperando a que cada uno termine antes de pasar al siguiente.</p>"
    },
    "exhaust": {
      "title": "Operador exhaust",
      "description": "<p>El operador <b>exhaust</b> en RxJS se utiliza para manejar flujos de observables de manera que, cuando un observable fuente emite un nuevo observable, el operador <b>solo escuchará al primer</b> observable y se ignorarán los nuevos observables emitidos hasta que el <b>primero termine</b>. En otras palabras, si el observable fuente sigue emitiendo observables, pero ya está 'trabajando' con uno, esos nuevos observables no serán escuchados hasta que el anterior termine.</p><p>En este ejmplo podemos comprobar como el delay del segundo observable impide que se ejecute el tercer observable.</p>"
    },
    "forkJoin": {
      "title": "Operador forkJoin",
      "description": "<p>El operador <b>forkJoin</b> en RxJS se utiliza para esperar a que todos los observables que se le pasen como argumentos <b>terminen</b> y, cuando todos hayan emitido su último valor, emite un solo <b>array con los últimos valores</b> de cada uno de esos observables.</p>"
    },
    "merge": {
      "title": "Operador merge",
      "description": "<p>El operador <b>merge</b> en RxJS se utiliza para combinar múltiples observables y emitir sus valores de manera <b>intercalada</b> (sin esperar a que uno termine antes de escuchar el siguiente). Los valores se emiten en el <b>mismo orden</b> en que los observables los producen, y todos los observables se suscriben y se ejecutan <b>simultáneamente</b>.</p>"
    },
    "mergeAll": {
      "title": "Operador mergeAll",
      "description": "<p>El operador <b>mergeAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de manera <b>diferente</b> a otros operadores como <b>concatAll</b>. Con mergeAll, cuando un observable emite otros observables, <b>todos</b> los observables se suscriben y se ejecutan de manera <b>simultánea</b>.</p>"
    },
    "race": {
      "title": "Operador race",
      "description": "<p>El operador <b>race</b> en RxJS se utiliza para <b>competir</b> entre varios observables y emitir los valores del <b>primer observable que emita algo</b>. Es decir, de todos los observables que se le pasen, el operador se suscribe solo al que primero emita un valor, y <b>descarta</b> los demás observables.</p>"
    },
    "startWith": {
      "title": "Operador startWith",
      "description": "<p>El operador <b>startWith</b> en RxJS se utiliza para emitir un <b>valor inicial antes</b> de que cualquier otro valor sea emitido por el observable. Es decir, puedes especificar un valor que se emitirá al principio, antes de que el observable comience a emitir sus propios valores.</p>"
    },
    "switchAll": {
      "title": "Operador switchAll",
      "description": "<p>El operador <b>switchAll</b> en RxJS se utiliza para aplanar un flujo de observables, pero de una manera especial: cuando un observable emite un <b>nuevo observable</b>, switchAll <b>deja de escuchar</b> al observable anterior y comienza a escuchar al nuevo observable. Es decir, siempre se suscribe solo al <b>último observable(s) emitido(s)</b> y cancela la suscripción a los anteriores.</p>"
    },
    "withLatestFrom": {
      "title": "Operador withLatestFrom",
      "description": "<p>El operador <b>withLatestFrom</b> en RxJS se utiliza para combinar el valor <b>más reciente</b> de un observable con los valores de otro observable, <b>sin suscribirse al segundo observable</b>. Esto significa que cuando el primer observable emite un valor, withLatestFrom toma el valor más reciente del segundo observable y lo combina con el valor emitido por el primer observable.</p>"
    }
  },

  "conditional": {
    "title": "Operadores condicionales",
    "description": "<b>Los operadores condicionales en RxJS</b> se utilizan para manejar flujos de datos de manera <b>condicional</b>, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "shortDescription": "Los operadores condicionales en RxJS se utilizan para manejar flujos de datos de manera condicional, es decir, ejecutar lógica basada en si se cumple o no una cierta condición.",
    "defaultIfEmpty": {
      "title": "Operador defaultIfEmpty",
      "description": "<p>El operador <b>defaultIfEmpty</b> en RxJS se utiliza para proporcionar un <b>valor por defecto</b> cuando un observable <b>no emite ningún valor</b>. Es decir, si el observable está vacío (no emite nada), defaultIfEmpty emite el valor que especifiques como predeterminado.</p>"
    },
    "every": {
      "title": "Operador every",
      "description": "<p>El operador <b>every</b> en RxJS se utiliza para comprobar si todos los valores emitidos por un observable <b>cumplen con una condición específica</b>. Devuelve un observable que <b>emite true</b> si todos los valores emitidos cumplen la condición, y <b>false</b> si al menos uno de los valores no la cumple.</p>"
    }
  },

  "transformation": {
    "title": "Operadores de transformación",
    "description": "<b>Los operadores de transformación de RxJS</b> son herramientas que te permiten cambiar (o 'transformar') los datos que fluyen a través de un flujo observable. Imagina que tienes un flujo de valores, como números u objetos, y quieres modificar, filtrar o reestructurar estos valores antes de que lleguen al observador final.",
    "shortDescription": "Los operadores de transformación de RxJS son herramientas para modificar los datos que fluyen por un observable.",
    "buffer": {
      "title": "Operador buffer",
      "description": "<p>El operador <b>buffer</b> de RxJS recopila las emisiones de un observable fuente en un array y las entrega juntas cuando otro observable, conocido como <b>disparador</b> (trigger), emite un valor. Es útil para agrupar valores durante intervalos de tiempo o en respuesta a eventos.<p><p>En este ejemplo contabilizamos los clicks que se hace en un botón cada 3 segundos.</p> "
    },
    "bufferCount": {
      "title": "Operador bufferCount",
      "description": "<p>El operador <b>bufferCount</b> de RxJS se utiliza para agrupar emisiones de un observable en 'buffers' o lotes de tamaño <b>fijo</b> y emitirlos como un array.</p><p>En este ejemplo emitiremos el array al hacer 5 clicks.</p>"
    },
    "bufferTime": {
      "title": "Operador bufferTime",
      "description": "<p>El operador <b>bufferTime</b> de RxJS agrupa las emisiones de un observable durante un período de <b>tiempo fijo</b> y las emite juntas como un array.</p><p>En este ejemplo, mostramos el array que se genera con la emisión del intervalo cada 3 segundos.</p>"
    },
    "bufferToogle": {
      "title": "Operador bufferToogle",
      "description": "<p>El operador <b>bufferToggle</b> de RxJS te permite recolectar valores emitidos por un observable en buffers (arreglos) y emitir esos buffers en función de señales provenientes de otros observables. Funciona abriendo y cerrando buffers basados en eventos disparados por observables de <b>apertura y cierre</b>.</p><p>En este ejemplo capturaremos los valores emitidos en un intervalo de 1 segundo desde que presionemos 'Start' hasta que presionemos 'Stop'.</p>"
    },
    "bufferWhen": {
      "title": "Operador bufferWhen",
      "description": "<p>El operador <b>bufferWhen</b> de RxJS permite recolectar valores emitidos por un observable fuente en 'buffers' (arreglos) y emitir esos buffers cuando <b>se cumple una condición</b>. La condición para cerrar cada buffer se define a través de una función que devuelve un observable. Cuando este observable emite un valor, el buffer se cierra y se inicia uno nuevo.</p><p>En este ejemplo capturaremos los valores emitidos por un intervalo de 1 segundo, cada vez que hagamos click en el botón.</p>"
    },
    "concatMap": {
      "title": "Operador concatMap",
      "description": "<p>El operador <b>concatMap</b> en RxJS se utiliza para encadenar observables uno tras otro, asegurándose de que se ejecuten en secuencia. Cuando concatMap recibe un valor, lo mapea a un nuevo observable (como una solicitud de red o un temporizador) y espera a que este se complete antes de pasar al siguiente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic, podemos ver en la consola cómo los observables se concatenan de manera ordenada, respetando su secuencia.</p>"
    },
    "exhaustMap": {
      "title": "Operador exhaustMap",
      "description": "<p>El operador <b>exhaustMap</b> en RxJS sirve para manejar flujos de datos <b>asincrónicos</b> asegurándote de que solo procese <b>una operación a la vez</b> y que ignore cualquier nueva acción mientras la operación actual sigue en curso.</p><p>En este ejemplo cargamos una lista de usuarios a través del clic de un botón. Podremos comprobar como no se carga la lista hasta que la llamada previa haya finalizado.</p>"
    },
    "expand": {
      "title": "Operador expand",
      "description": "<p>El operador <b>expand</b> en RxJS se utiliza para generar un flujo de valores de manera <b>recursiva</b>, es decir, permite que cada valor emitido pueda <b>generar nuevos valores</b> basados en una lógica definida.</p><p>En este ejemplo, a cada valor emitido le sumamos 10 hasta repetir 5 veces la operación.</p>"
    },
    "groupBy": {
      "title": "Operador groupBy",
      "description": "<p>El operador <b>groupBy</b> de RxJS se utiliza para agrupar elementos emitidos por un observable <b>según una clave</b> que tú defines. Piensa en él como una forma de separar un flujo de datos en diferentes 'cajones' según alguna característica.</p><p>En este ejemplo agrupamos las especies en diferentes arreglos, a través de un mergeMap y un toArray.</p>"
    },
    "map": {
      "title": "Operador map",
      "description": "<p>El operador <b>map</b> en RxJS aplica una función a cada valor emitido por un observable y devuelve un observable que emite los valores transformados.</p><p>En este ejemplo, transformamos el nombre del usuario utilizando el operador map y usamos el método map del arreglo para actualizar el nombre de cada elemento dentro de él.</p>"
    },
    "mapTo": {
      "title": "Operador mapTo",
      "description": "<p>El operador <b>mapTo</b> en RxJS reemplaza cada valor emitido por un observable con un valor específico que proporcionas.</p><p>En este ejemplo, con el operador mapTo, reemplazamos todos los valores del observable con el valor <b>fresa</b>.</p>"
    },
    "mergeMap": {
      "title": "Operador mergeMap",
      "description": "<p>El operador <b>mergeMap</b> en RxJS se utiliza para transformar los valores emitidos por un observable en otros observables y luego <b>'aplana'</b> o combina todas esas emisiones en un único flujo de datos. Esto es útil cuando deseas realizar múltiples operaciones asíncronas en secuencia y combinar sus resultados.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2.</p>"
    },
    "mergeMapTo": {
      "title": "Operador mergeMapTo",
      "description": "<p>El operador <b>mergeMapTo</b> en RxJS se utiliza para reemplazar cada valor emitido por un observable con un observable diferente que especifiques, y luego 'aplana' todos los resultados en un único flujo de salida.</p><p>En este ejemplo, combinamos un observable compuesto por una lista de letras con un observable que contiene un rango numérico del 1 al 2. <b>A diferencia de mergeMap</b>, no tomamos en cuenta la salida del primer observable, emitiendo el <b>mismo valor</b> para cada letra.</p>"
    },
    "mergeScan": {
      "title": "Operador mergeScan",
      "description": "<p>El operador <b>mergeScan</b> de RxJS es como una combinación de un <b>reduce</b> y un <b>mergeMap</b>, pero se aplica a un flujo de datos (un observable) en lugar de a una colección estática como un array. Se utiliza cuando quieres mantener un estado acumulativo a medida que se emiten valores de un observable, y al mismo tiempo generar nuevos observables a partir de cada valor emitido.</p><p>En este ejemplo sumamos de forma acomulativa los números del obersevable.</p>"
    },
    "pairwise": {
      "title": "Operador pairwise",
      "description": "<p>El operador <b>pairwise</b> de RxJS es un operador simple que agrupa los valores consecutivos emitidos por un observable en <b>pares</b>. Cada vez que el observable emite un nuevo valor, este operador toma el valor <b>anterior y el actual</b> y los combina en un array de dos elementos.</p><p>En este ejemplo podemos comprobar como se van concatenando en un array los dos últimos valores emitidos.</p>"
    },
    "partition": {
      "title": "Operador partition",
      "description": "<p>El operador <b>partition</b> de RxJS es una forma sencilla de dividir un flujo de datos (observable) en dos partes, según una condición. Básicamente, separa los valores emitidos en dos observables diferentes:</p><p>- <b>Un observable</b> para los valores que cumplen con la condición.</p><p>- <b>Otro observable</b> para los valores que no la cumplen.</p><p>En este ejemplo agrupamos los animales en dos grupos, los que son gatos y los que no lo son.</p>"
    },
    "pluck": {
      "title": "Operador pluck",
      "description": "<p>El operador <b>pluck</b> de RxJS es una forma sencilla de extraer un valor específico de un objeto emitido por un observable. Básicamente, es como acceder a una propiedad directamente usando su <b>nombre</b>, pero en el contexto de un flujo de datos.</p><p>En este ejemplo vamos a mostrar por consola los nombres de los animales de nuestro observable.</p>"
    },
    "scan": {
      "title": "Operador scan",
      "description": "<p>El operador <b>scan</b> de RxJS es muy similar a la función <b>reduce de los arreglos</b>, pero se aplica a flujos de datos (streams). Básicamente, acumula un valor a lo largo del tiempo, a medida que van llegando nuevos valores al flujo.</p><p>En este ejemplo sumamos de forma acumulativa los valores del observable.</p>"
    },
    "switchMap": {
      "title": "Operador switchMap",
      "description": "<p>El operador <b>switchMap</b> en RxJS se utiliza para cambiar de un observable a uno nuevo cada vez que el observable original emite un nuevo valor. Cuando esto ocurre, switchMap <b>cancela (o 'se desuscribe de')</b> el observable anterior y solo escucha al más reciente.</p><p>En este ejemplo, combinamos el observable de un evento clic con el observable de un intervalo. Cada vez que hacemos clic en el botón, podemos ver en la consola cómo se cancela el observable anterior.</p>"
    },
    "window": {
      "title": "Operador window",
      "description": "<p>El operador <b>window</b> de RxJS divide un flujo de datos (observable) en <b>sub-observables</b>, llamados <b>'ventanas'</b>. Cada ventana agrupa los elementos emitidos por el flujo original según un criterio definido, y se cierra cuando ocurre un evento determinado.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres</p>"
    },
    "windowCount": {
      "title": "Operador windowCount",
      "description": "<p>El operador <b>windowCount</b> de RxJS divide un flujo de datos (observable) en sub-observables (ventanas) basados en un <b>número fijo</b> de emisiones. Es decir, cada 'ventana' agrupa una cantidad específica de valores emitidos.</p><p>En este ejemplo agrupamos números en 'ventanas' de tres comenzando cada 2 valores.</p>"
    },
    "windowTime": {
      "title": "Operador windowTime",
      "description": "<p>El operador <b>windowTime</b> de RxJS divide un flujo de datos (observable) en <b>'ventanas' de tiempo fijo</b>. Cada ventana es un sub-observable que agrupa los valores emitidos durante un intervalo de tiempo determinado.</p><p>En este ejemplo agrupamos los valores emitidos por el intervalo en ventanas de 3 segundos.</p>"
    },
    "windowToogle": {
      "title": "Operador windowToogle",
      "description": "<p>El operador <b>windowToggle</b> de RxJS divide un flujo de datos (observable) en ventanas que se abren y cierran según dos observables:</p><p><b>- Abridor (openings)</b>: Un observable que indica cuándo abrir una nueva ventana.</p><p>- <b>Cierre (closings)</b>: Una función que genera un observable para decidir cuándo cerrar esa ventana.</p><p>En este ejemplo emitimos los valores del intervalo abriendo una nueva ventana cada 5 segundos y cerrándola cada 3 segundos.</p>"
    },
    "windowWhen": {
      "title": "Operador windowWhen",
      "description": "<p>El operador <b>windowWhen</b> de RxJS divide un flujo de datos (observable) en ventanas que se <b>cierran y abren</b> según un criterio personalizado. Tú decides cuándo una ventana debe cerrarse y una nueva debe abrirse usando una función que genera observables.</p><p>En este ejemplo emitimos valores de un intervalo que se abre y cierra cada 3 segundos.</p>"
    }
  }
}
